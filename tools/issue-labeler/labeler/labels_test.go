package labeler

import (
	"reflect"
	"regexp"
	"testing"

	"github.com/google/go-github/v68/github"
	"golang.org/x/exp/slices"
)

func TestExtractAffectedResources(t *testing.T) {
	cases := []struct {
		name              string
		body              string
		expectedResources []string
	}{
		{
			name:              "2023 bug",
			body:              "<!--- Please keep this note for the community --->\r\n\r\n### Community Note\r\n\r\n* Please vote on this issue by adding a üëç [reaction](https://blog.github.com/2016-03-10-add-reactions-to-pull-requests-issues-and-comments/) to the original issue to help the community and maintainers prioritize this request.\r\n* Please do not leave _+1_ or _me too_ comments, they generate extra noise for issue followers and do not help prioritize the request.\r\n* If you are interested in working on this issue or have submitted a pull request, please leave a comment.\r\n* If an issue is assigned to the `modular-magician` user, it is either in the process of being autogenerated, or is planned to be autogenerated soon. If an issue is assigned to a user, that user is claiming responsibility for the issue. If an issue is assigned to `hashibot`, a community member has claimed the issue already.\r\n\r\n<!--- Thank you for keeping this note for the community --->\r\n\r\n### Terraform Version\r\n\r\n<!--- Please run `terraform -v` to show the Terraform core version and provider version(s). If you are not running the latest version of Terraform or the provider, please upgrade because your issue may have already been fixed. [Terraform documentation on provider versioning](https://www.terraform.io/docs/configuration/providers.html#provider-versions). --->\r\nTerraform v1.3.7\r\non linux_amd64\r\nprovider registry.terraform.io/hashicorp/google v4.48.0\r\n\r\n### Affected Resource(s)\r\n\r\n<!--- Please list the affected resources and data sources. --->\r\n\r\n* google_container_node_pool\r\n* google_container_cluster\r\n\r\n### Terraform Configuration Files\r\n\r\n<!--- Information about code formatting: https://help.github.com/articles/basic-writing-and-formatting-syntax/#quoting-code --->\r\n\r\n```tf\r\nnode_config {\r\n    tags = null\r\n}\r\n```\r\n### Expected Behavior\r\n\r\nIn above code, if there already exists a list of tags defined in the `node_config` block then I would expect TF to ignore this tags field and leave them as they are\r\n\r\n### Actual Behavior\r\n\r\nTF sets the tags to an empty list, [], thus removing existing tags\r\n\r\n### Steps to Reproduce\r\n\r\n1. Create google nodepool TF code with node_config block and set `tags` within the block to a list of strings, i.e. `tags=[ \"one\", \"two\" ]`\r\n2. Terraform apply to create the nodepool with this node config\r\n3. Now update code to say `tags=null`\r\n4. Terraform apply and see the tags removed rather than ignored\r\n",
			expectedResources: []string{"google_container_node_pool", "google_container_cluster"},
		},
		{
			name:              "2023 enhancement",
			body:              "<!--- Please keep this note for the community --->\r\n\r\n### Community Note\r\n\r\n* Please vote on this issue by adding a üëç [reaction](https://blog.github.com/2016-03-10-add-reactions-to-pull-requests-issues-and-comments/) to the original issue to help the community and maintainers prioritize this request\r\n* Please do not leave \"+1\" or \"me too\" comments, they generate extra noise for issue followers and do not help prioritize the request\r\n* If you are interested in working on this issue or have submitted a pull request, please leave a comment. If the issue is assigned to the \"modular-magician\" user, it is either in the process of being autogenerated, or is planned to be autogenerated soon. If the issue is assigned to a user, that user is claiming responsibility for the issue. If the issue is assigned to \"hashibot\", a community member has claimed the issue already.\r\n\r\n<!--- Thank you for keeping this note for the community --->\r\n\r\n### Description\r\n\r\n<!--- Please leave a helpful description of the feature request here. Including use cases and why it would help you is a great way to convince maintainers to spend time on it. --->\r\n\r\nSupport for creating mute configs in SCC:\r\nhttps://cloud.google.com/security-command-center/docs/reference/rest/v1/organizations.muteConfigs/create\r\n\r\n### New or Affected Resource(s)\r\n\r\n<!--- Please list the new or affected resources and data sources. --->\r\n\r\n* google_scc_mute_config\r\n\r\n### Potential Terraform Configuration\r\n\r\n<!--- Information about code formatting: https://help.github.com/articles/basic-writing-and-formatting-syntax/#quoting-code --->\r\n\r\n```tf\r\nresource \"google_scc_mute_config\" \"my_config\" {\r\n  config_id    = \"my-config\"\r\n  organisation = \"12345678\"\r\n  description = \"My Awesome Mute Config\"\r\n  filter = \"severity=LOW\"\r\n}\r\n```\r\n\r\nCurious as to why the current notification config is only supported at the org level? Even though the parent config can exist at folder or project level? (Same applies here)\r\n\r\n### References\r\n\r\n<!---\r\nInformation about referencing Github Issues: https://help.github.com/articles/basic-writing-and-formatting-syntax/#referencing-issues-and-pull-requests\r\n\r\nAre there any other GitHub issues (open or closed) or pull requests that should be linked here? Vendor blog posts or documentation?\r\n--->\r\n\r\n* #0000\r\n\r\n<!---\r\nNote Google Cloud customers who are working with a dedicated Technical Account Manager / Customer Engineer: to expedite the investigation and resolution of this issue, please refer to these instructions: https://github.com/hashicorp/terraform-provider-google/wiki/Customer-Contact#raising-gcp-internal-issues-with-the-provider-development-team\r\n--->\r\n",
			expectedResources: []string{"google_scc_mute_config"},
		},
		{
			name:              "google_* comment ignored",
			body:              "<!--- Please keep this note for the community --->\r\n\r\n### Community Note\r\n\r\n* Please vote on this issue by adding a üëç [reaction](https://blog.github.com/2016-03-10-add-reactions-to-pull-requests-issues-and-comments/) to the original issue to help the community and maintainers prioritize this request\r\n* Please do not leave \"+1\" or \"me too\" comments, they generate extra noise for issue followers and do not help prioritize the request\r\n* If you are interested in working on this issue or have submitted a pull request, please leave a comment. If the issue is assigned to the \"modular-magician\" user, it is either in the process of being autogenerated, or is planned to be autogenerated soon. If the issue is assigned to a user, that user is claiming responsibility for the issue. If the issue is assigned to \"hashibot\", a community member has claimed the issue already.\r\n\r\n<!--- Thank you for keeping this note for the community --->\r\n\r\n### Description\r\n\r\n<!--- Please leave a helpful description of the feature request here. Including use cases and why it would help you is a great way to convince maintainers to spend time on it. --->\r\n\r\nSupport for creating mute configs in SCC:\r\nhttps://cloud.google.com/security-command-center/docs/reference/rest/v1/organizations.muteConfigs/create\r\n\r\n### New or Affected Resource(s)\r\n\r\n<!--- Please list the new or affected resources and data sources. Use google_* if all resources or data sources are affected. --->\r\n\r\n* google_scc_mute_config\r\n\r\n### Potential Terraform Configuration\r\n\r\n<!--- Information about code formatting: https://help.github.com/articles/basic-writing-and-formatting-syntax/#quoting-code --->\r\n\r\n```tf\r\nresource \"google_scc_mute_config\" \"my_config\" {\r\n  config_id    = \"my-config\"\r\n  organisation = \"12345678\"\r\n  description = \"My Awesome Mute Config\"\r\n  filter = \"severity=LOW\"\r\n}\r\n```\r\n\r\nCurious as to why the current notification config is only supported at the org level? Even though the parent config can exist at folder or project level? (Same applies here)\r\n\r\n### References\r\n\r\n<!---\r\nInformation about referencing Github Issues: https://help.github.com/articles/basic-writing-and-formatting-syntax/#referencing-issues-and-pull-requests\r\n\r\nAre there any other GitHub issues (open or closed) or pull requests that should be linked here? Vendor blog posts or documentation?\r\n--->\r\n\r\n* #0000\r\n\r\n<!---\r\nNote Google Cloud customers who are working with a dedicated Technical Account Manager / Customer Engineer: to expedite the investigation and resolution of this issue, please refer to these instructions: https://github.com/hashicorp/terraform-provider-google/wiki/Customer-Contact#raising-gcp-internal-issues-with-the-provider-development-team\r\n--->\r\n",
			expectedResources: []string{"google_scc_mute_config"},
		},
		{
			name:              "no resources returns empty slice",
			body:              "### New or Affected Resource(s):\r\n#",
			expectedResources: []string{},
		},
		{
			name:              "h1",
			body:              "\n# New or Affected Resource(s):\r\ngoogle_scc_mute_config",
			expectedResources: []string{"google_scc_mute_config"},
		},
		{
			name:              "h2",
			body:              "\n## New or Affected Resource(s):\r\ngoogle_scc_mute_config",
			expectedResources: []string{"google_scc_mute_config"},
		},
		{
			name:              "h4",
			body:              "\n#### New or Affected Resource(s):\r\ngoogle_scc_mute_config",
			expectedResources: []string{"google_scc_mute_config"},
		},
	}

	for _, tc := range cases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			resources := ExtractAffectedResources(tc.body)
			if !slices.Equal(resources, tc.expectedResources) {
				t.Errorf("Expected %v, got %v", tc.expectedResources, resources)
			}
		})
	}
}

func TestEnrolledTeamsData(t *testing.T) {
	// Smoke test to make sure enrolled teams data can be converted to a regex -> label map
	_, err := BuildRegexLabels(EnrolledTeamsYaml)
	if err != nil {
		t.Logf("Error converting enrolled_teams.yml to regexpLabels: %s", err)
		t.FailNow()
	}
}

func TestBuildRegexLabels(t *testing.T) {
	cases := map[string]struct {
		yaml                 []byte
		expectedRegexpLabels []RegexpLabel
	}{
		"empty yaml": {
			yaml:                 []byte{},
			expectedRegexpLabels: []RegexpLabel{},
		},
		"labels with resources": {
			yaml: []byte(`
service/service1:
  resources:
  - google_service1_.*
service/service2:
  resources:
  - google_service2_resource1
  - google_service2_resource2`),
			expectedRegexpLabels: []RegexpLabel{
				{
					Regexp: regexp.MustCompile("^google_service1_.*$"),
					Label:  "service/service1",
				},
				{
					Regexp: regexp.MustCompile("^google_service2_resource1$"),
					Label:  "service/service2",
				},
				{
					Regexp: regexp.MustCompile("^google_service2_resource2$"),
					Label:  "service/service2",
				},
			},
		},
		"label with team": {
			yaml: []byte(`
service/service1:
  team: service1-team
  resources:
    - google_service1_resource1`),
			expectedRegexpLabels: []RegexpLabel{
				{
					Regexp: regexp.MustCompile("^google_service1_resource1$"),
					Label:  "service/service1",
				},
			},
		},
	}

	for tn, tc := range cases {
		tc := tc
		t.Run(tn, func(t *testing.T) {
			t.Parallel()
			regexpLabels, err := BuildRegexLabels(tc.yaml)
			if err != nil {
				t.Logf("Unable to read enrolled teams: %s", err)
				t.FailNow()
			}
			if !reflect.DeepEqual(regexpLabels, tc.expectedRegexpLabels) {
				t.Errorf("want %v; got %v", tc.expectedRegexpLabels, regexpLabels)
			}
		})
	}
}

func TestComputeLabels(t *testing.T) {
	defaultRegexpLabels := []RegexpLabel{
		{
			Regexp: regexp.MustCompile("^google_service1_.*$"),
			Label:  "service/service1",
		},
		{
			Regexp: regexp.MustCompile("^google_service2_resource1$"),
			Label:  "service/service2-subteam1",
		},
		{
			Regexp: regexp.MustCompile("^google_service2_resource2$"),
			Label:  "service/service2-subteam2",
		},
		{
			Regexp: regexp.MustCompile("^google_service1_resource5$"),
			Label:  "service/service1-subteam1",
		},
		{
			Regexp: regexp.MustCompile("^google_resource6$"),
			Label:  "service/service3",
		},
	}
	cases := map[string]struct {
		resources      []string
		regexpLabels   []RegexpLabel
		expectedLabels []string
	}{
		"empty resources -> empty labels": {
			resources:      []string{},
			regexpLabels:   defaultRegexpLabels,
			expectedLabels: []string{},
		},
		"unmatched resources -> empty labels": {
			resources:      []string{"google_foobar_baz"},
			regexpLabels:   defaultRegexpLabels,
			expectedLabels: []string{},
		},
		"empty regexpLabels -> empty labels": {
			resources:      []string{"google_service1_resource1"},
			regexpLabels:   []RegexpLabel{},
			expectedLabels: []string{},
		},
		"single matched resource": {
			resources:      []string{"google_service1_resource1"},
			regexpLabels:   defaultRegexpLabels,
			expectedLabels: []string{"service/service1"},
		},
		"exact resource match": {
			resources:      []string{"google_resource6"},
			regexpLabels:   defaultRegexpLabels,
			expectedLabels: []string{"service/service3"},
		},
		"no partial match allowed": {
			resources:      []string{"google_resource6_foo"},
			regexpLabels:   defaultRegexpLabels,
			expectedLabels: []string{},
		},
		"only return first label matching a resource": {
			resources:      []string{"google_service1_resource5"},
			regexpLabels:   defaultRegexpLabels,
			expectedLabels: []string{"service/service1"},
		},
		"multiple resources, some matched": {
			resources:      []string{"google_service1_resource1", "google_foobar_baz", "google_service2_resource1", "google_service2_resource2"},
			regexpLabels:   defaultRegexpLabels,
			expectedLabels: []string{"service/service1", "service/service2-subteam1", "service/service2-subteam2"},
		},
		"deduplicate labels": {
			resources:      []string{"google_service1_resource5", "google_service1_resource5"},
			regexpLabels:   defaultRegexpLabels,
			expectedLabels: []string{"service/service1"},
		},
	}

	for tn, tc := range cases {
		tc := tc
		t.Run(tn, func(t *testing.T) {
			t.Parallel()
			labels := ComputeLabels(tc.resources, tc.regexpLabels)
			if !slices.Equal(labels, tc.expectedLabels) {
				t.Errorf("want %v; got %v", tc.expectedLabels, labels)
			}
		})
	}
}

func TestComputeLabelChanges(t *testing.T) {
	tests := []struct {
		name           string
		existingLabels []*github.Label
		desiredLabels  []string
		desiredColor   string
		want           []LabelChange
	}{
		{
			name:           "new labels only",
			existingLabels: []*github.Label{},
			desiredLabels:  []string{"bug", "enhancement"},
			desiredColor:   "FF0000",
			want: []LabelChange{
				{Name: "bug", Color: "FF0000", IsNew: true, NeedsUpdate: false},
				{Name: "enhancement", Color: "FF0000", IsNew: true, NeedsUpdate: false},
			},
		},
		{
			name: "existing labels with correct color",
			existingLabels: []*github.Label{
				{Name: github.Ptr("xyz"), Color: github.Ptr("FF0000")},
				{Name: github.Ptr("bug"), Color: github.Ptr("FF0000")},
				{Name: github.Ptr("enhancement"), Color: github.Ptr("FF0000")},
			},
			desiredLabels: []string{"bug", "enhancement"},
			desiredColor:  "FF0000",
			want: []LabelChange{
				{Name: "bug", Color: "FF0000", IsNew: false, NeedsUpdate: false},
				{Name: "enhancement", Color: "FF0000", IsNew: false, NeedsUpdate: false},
			},
		},
		{
			name: "existing labels with wrong color",
			existingLabels: []*github.Label{
				{Name: github.Ptr("bug"), Color: github.Ptr("00FF00")},
				{Name: github.Ptr("enhancement"), Color: github.Ptr("00FF00")},
			},
			desiredLabels: []string{"bug", "enhancement"},
			desiredColor:  "FF0000",
			want: []LabelChange{
				{Name: "bug", Color: "FF0000", IsNew: false, NeedsUpdate: true},
				{Name: "enhancement", Color: "FF0000", IsNew: false, NeedsUpdate: true},
			},
		},
		{
			name: "mixed existing and new labels",
			existingLabels: []*github.Label{
				{Name: github.Ptr("bug"), Color: github.Ptr("FF0000")},
			},
			desiredLabels: []string{"bug", "enhancement"},
			desiredColor:  "FF0000",
			want: []LabelChange{
				{Name: "bug", Color: "FF0000", IsNew: false, NeedsUpdate: false},
				{Name: "enhancement", Color: "FF0000", IsNew: true, NeedsUpdate: false},
			},
		},
		{
			name: "case insensitive color comparison",
			existingLabels: []*github.Label{
				{Name: github.Ptr("bug"), Color: github.Ptr("ff0000")},
			},
			desiredLabels: []string{"bug"},
			desiredColor:  "FF0000",
			want: []LabelChange{
				{Name: "bug", Color: "FF0000", IsNew: false, NeedsUpdate: false},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := ComputeLabelChanges(tt.existingLabels, tt.desiredLabels, tt.desiredColor)
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("ComputeLabelChanges() = %v, want %v", got, tt.want)
			}
		})
	}
}
