// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmApiManagementDiagnostic() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmApiManagementDiagnosticCreateUpdate,
        Read: resourceArmApiManagementDiagnosticRead,
        Update: resourceArmApiManagementDiagnosticCreateUpdate,
        Delete: resourceArmApiManagementDiagnosticDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "resource_group_name": resourceGroupNameSchema(),

            "api_management_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
            },

            "logger_id": {
                Type: schema.TypeString,
                Required: true,
            },

            "always_log": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(apimanagement.AllErrors),
                }, false),
            },

            "backend": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "request": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "body_bytes": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "headers": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeString,
                                        },
                                    },
                                },
                            },
                        },
                        "response": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "body_bytes": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "headers": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeString,
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "enable_http_correlation_headers": {
                Type: schema.TypeBool,
                Optional: true,
                Default: true,
            },

            "frontend": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "request": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "body_bytes": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "headers": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeString,
                                        },
                                    },
                                },
                            },
                        },
                        "response": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "body_bytes": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "headers": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeString,
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "sampling_percentage": {
                Type: schema.TypeFloat,
                Optional: true,
            },

            "sampling_type": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(apimanagement.Fixed),
                }, false),
            },
        },
    }
}

func resourceArmApiManagementDiagnosticCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).apiManagementDiagnosticClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group_name").(string)
    serviceName := d.Get("api_management_name").(string)

    if requireResourcesToBeImported {
        resp, err := client.Get(ctx, resourceGroup, serviceName, name)
        if err != nil {
            if !utils.ResponseWasNotFound(resp.Response) {
                return fmt.Errorf("Error checking for present of existing Api Management Diagnostic %q (Resource Group %q / Api Management Name %q): %+v", name, resourceGroup, serviceName, err)
            }
        }
        if !utils.ResponseWasNotFound(resp.Response) {
            return tf.ImportAsExistsError("azurerm_api_management_diagnostic", *resp.ID)
        }
    }

    alwaysLog := d.Get("always_log").(string)
    backend := d.Get("backend").([]interface{})
    enableHttpCorrelationHeaders := d.Get("enable_http_correlation_headers").(bool)
    frontend := d.Get("frontend").([]interface{})
    loggerId := d.Get("logger_id").(string)
    samplingPercentage := d.Get("sampling_percentage").(float64)
    samplingType := d.Get("sampling_type").(string)

    parameters := apimanagement.DiagnosticContract{
        DiagnosticContractProperties: &apimanagement.DiagnosticContractProperties{
            AlwaysLog: apimanagement.AlwaysLog(alwaysLog),
            Backend: expandArmApiManagementDiagnosticPipelineDiagnosticSettings(backend),
            EnableHTTPCorrelationHeaders: utils.Bool(enableHttpCorrelationHeaders),
            Frontend: expandArmApiManagementDiagnosticPipelineDiagnosticSettings(frontend),
            LoggerID: utils.String(loggerId),
            Sampling: &apimanagement.SamplingSettings{
                Percentage: utils.Float(samplingPercentage),
                SamplingType: apimanagement.SamplingType(samplingType),
            },
        },
    }


    if _, err := client.CreateOrUpdate(ctx, resourceGroup, serviceName, name, parameters, ""); err != nil {
        return fmt.Errorf("Error creating Api Management Diagnostic %q (Resource Group %q / Api Management Name %q): %+v", name, resourceGroup, serviceName, err)
    }


    resp, err := client.Get(ctx, resourceGroup, serviceName, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Api Management Diagnostic %q (Resource Group %q / Api Management Name %q): %+v", name, resourceGroup, serviceName, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Api Management Diagnostic %q (Resource Group %q / Api Management Name %q) ID", name, resourceGroup, serviceName)
    }
    d.SetId(*resp.ID)

    return resourceArmApiManagementDiagnosticRead(d, meta)
}

func resourceArmApiManagementDiagnosticRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).apiManagementDiagnosticClient
    ctx := meta.(*ArmClient).StopContext

    id, err := parseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    serviceName := id.Path["service"]
    name := id.Path["diagnostics"]

    resp, err := client.Get(ctx, resourceGroup, serviceName, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Api Management Diagnostic %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Api Management Diagnostic %q (Resource Group %q / Api Management Name %q): %+v", name, resourceGroup, serviceName, err)
    }


    d.Set("name", resp.Name)
    d.Set("resource_group_name", resourceGroup)
    d.Set("api_management_name", serviceName)
    if properties := resp.DiagnosticContractProperties; properties != nil {
        d.Set("always_log", string(properties.AlwaysLog))
        if err := d.Set("backend", flattenArmApiManagementDiagnosticPipelineDiagnosticSettings(properties.Backend)); err != nil {
            return fmt.Errorf("Error setting `backend`: %+v", err)
        }
        d.Set("enable_http_correlation_headers", properties.EnableHTTPCorrelationHeaders)
        if err := d.Set("frontend", flattenArmApiManagementDiagnosticPipelineDiagnosticSettings(properties.Frontend)); err != nil {
            return fmt.Errorf("Error setting `frontend`: %+v", err)
        }
        d.Set("logger_id", properties.LoggerID)
        if sampling := properties.Sampling; sampling != nil {
            d.Set("sampling_percentage", sampling.Percentage)
            d.Set("sampling_type", string(sampling.SamplingType))
        }
    }

    return nil
}


func resourceArmApiManagementDiagnosticDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).apiManagementDiagnosticClient
    ctx := meta.(*ArmClient).StopContext


    id, err := parseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    serviceName := id.Path["service"]
    name := id.Path["diagnostics"]

    if _, err := client.Delete(ctx, resourceGroup, serviceName, name, ""); err != nil {
        return fmt.Errorf("Error deleting Api Management Diagnostic %q (Resource Group %q / Api Management Name %q): %+v", name, resourceGroup, serviceName, err)
    }

    return nil
}

func expandArmApiManagementDiagnosticPipelineDiagnosticSettings(input []interface{}) *apimanagement.PipelineDiagnosticSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    request := v["request"].([]interface{})
    response := v["response"].([]interface{})

    result := apimanagement.PipelineDiagnosticSettings{
        Request: expandArmApiManagementDiagnosticHTTPMessageDiagnostic(request),
        Response: expandArmApiManagementDiagnosticHTTPMessageDiagnostic(response),
    }
    return &result
}

func expandArmApiManagementDiagnosticHTTPMessageDiagnostic(input []interface{}) *apimanagement.HTTPMessageDiagnostic {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    headers := v["headers"].([]interface{})
    bodyBytes := v["body_bytes"].(int)

    result := apimanagement.HTTPMessageDiagnostic{
        Body: &apimanagement.BodyDiagnosticSettings{
            Bytes: utils.Int32(int32(bodyBytes)),
        },
        Headers: utils.ExpandStringArray(headers),
    }
    return &result
}


func flattenArmApiManagementDiagnosticPipelineDiagnosticSettings(input *apimanagement.PipelineDiagnosticSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["request"] = flattenArmApiManagementDiagnosticHTTPMessageDiagnostic(input.Request)
    result["response"] = flattenArmApiManagementDiagnosticHTTPMessageDiagnostic(input.Response)

    return []interface{}{result}
}

func flattenArmApiManagementDiagnosticHTTPMessageDiagnostic(input *apimanagement.HTTPMessageDiagnostic) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if body := input.Body; body != nil {
        if bodyBytes := body.Bytes; bodyBytes != nil {
            result["body_bytes"] = int(*bodyBytes)
        }
    }
    result["headers"] = utils.FlattenStringArray(input.Headers)

    return []interface{}{result}
}
