
if deletionPolicy := d.Get("deletion_policy"); deletionPolicy == "ABANDON" {
    // Allows for database to be abandoned without deletion to avoid deletion failing
    // for Postgres databases in some circumstances due to existing SQL users
    return nil
}

billingProject := ""

project, err := getProject(d, config)
if err != nil {
    return fmt.Errorf("Error fetching project for Database: %s", err)
}
billingProject = project

lockName, err := replaceVars(d, config, "google-sql-database-instance-{{project}}-{{instance}}")
if err != nil {
    return err
}
mutexKV.Lock(lockName)
defer mutexKV.Unlock(lockName)

url, err := replaceVars(d, config, "{{SQLBasePath}}projects/{{project}}/instances/{{instance}}/databases/{{name}}")
if err != nil {
    return err
}

var obj map[string]interface{}
log.Printf("[DEBUG] Deleting Database %q", d.Id())

// err == nil indicates that the billing_project value was found
if bp, err := getBillingProject(d, config); err == nil {
    billingProject = bp
}

res, err := sendRequestWithTimeout(config, "DELETE", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutDelete))
if err != nil {
    return handleNotFoundError(err, d, "Database")
}

err = sqlAdminOperationWaitTime(
    config, res, project, "Deleting Database", userAgent,
    d.Timeout(schema.TimeoutDelete))

if err != nil {
    return err
}

log.Printf("[DEBUG] Finished deleting Database %q: %#v", d.Id(), res)
return nil