// Such custom code is necessary as the Cluster's certificate authority has to be retrieved via a dedicated 
// getCertificateAuthority API.  
// See https://cloud.google.com/memorystore/docs/cluster/reference/rest/v1/projects.locations.clusters/getCertificateAuthority#http-request
// for details about this API.
config := meta.(*transport_tpg.Config)

userAgent, err :=  tpgresource.GenerateUserAgentString(d, config.UserAgent)
if err != nil {
  return nil, err
}

// Only clusters with TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION mode have certificate authority set
if v, ok := res["transitEncryptionMode"].(string); !ok || v!="TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION" {
    return res, nil
}

url, err := tpgresource.ReplaceVars(d, config, "{{"{{"}}RedisBasePath{{"}}"}}projects/{{"{{"}}project{{"}}"}}/locations/{{"{{"}}region{{"}}"}}/clusters/{{"{{"}}name{{"}}"}}/certificateAuthority")
if err != nil {
    return nil, err
}

billingProject := ""

project, err := tpgresource.GetProject(d, config)
if err != nil {
    return nil, fmt.Errorf("Error fetching project for Cluster: %s", err)
}

billingProject = project

// err == nil indicates that the billing_project value was found
if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
    billingProject = bp
}

certificateAuthority, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
    Config: config,
    Method: "GET",
    Project: billingProject,
    RawURL: url,
    UserAgent: userAgent,
})
if err != nil {
    return nil, fmt.Errorf("Error reading certificateAuthority: %s", err)
}

flattenRedisClusterManagedServerCaCaCertsCertificates := func(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

flattenRedisClusterManagedServerCaCaCerts := func (v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"certificates": flattenRedisClusterManagedServerCaCaCertsCertificates(original["certificates"], d, config),
		})
	}
	return transformed
}

flattenRedisClusterManagedServerCa := func (v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ca_certs"] =
		flattenRedisClusterManagedServerCaCaCerts(original["caCerts"], d, config)
	return []interface{}{transformed}
}

if err := d.Set("managed_server_ca", flattenRedisClusterManagedServerCa(certificateAuthority["managedServerCa"], d, config)); err != nil {
    return nil, fmt.Errorf("Error reading Cluster: %s", err)
}

return res, nil