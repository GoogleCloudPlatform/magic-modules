///////////////////////////////////////////////////////////////////////////////////////////////////
// Modify response for the following fields that are ignore_read (i.e. removed in the response): //
///////////////////////////////////////////////////////////////////////////////////////////////////

handlers, ok := res["handlers"].([]interface{})
if !ok { return res, nil }

for i, rawHandler := range handlers {
    handler, ok := rawHandler.(map[string]interface{})
    if !ok { continue }

    // Helper to process both eventHandler and lifecycleHandler
    processSubHandler := func(jsonKey, tfKey string) {
        
        // 1. Drill down to fulfillment in the generic Map (res)
        subHandler, ok := handler[jsonKey].(map[string]interface{})
        if !ok { return } 

        fulfillment, ok := subHandler["fulfillment"].(map[string]interface{})
        if !ok { return }

        // 2. Construct the Base Terraform Path (stops at fulfillment.0)
        // Example: handlers.0.event_handler.0.fulfillment.0
        baseFulfillmentPath := fmt.Sprintf("handlers.%d.%s.0.fulfillment.0", i, tfKey)


        // --- Handle Advanced Settings ---
        if advancedSettings, ok := fulfillment["advancedSettings"].(map[string]interface{}); ok {
            
            // Audio Export
            audioPath := baseFulfillmentPath + ".advanced_settings.0.audio_export_gcs_destination.0"
            if val := d.Get(audioPath); val != nil {
                if m, ok := val.(map[string]interface{}); ok && len(m) > 0 {
                    advancedSettings["audioExportGcsDestination"] = m
                }
            }

            // Logging Settings
            getLogBool := func(field string) bool {
                path := fmt.Sprintf("%s.advanced_settings.0.logging_settings.0.%s", baseFulfillmentPath, field)
                if v, ok := d.Get(path).(bool); ok {
                    return v
                }
                return false
            }

            advancedSettings["loggingSettings"] = map[string]interface{}{
                "enableConsentBasedRedaction": getLogBool("enable_consent_based_redaction"),
                "enableInteractionLogging":    getLogBool("enable_interaction_logging"),
                "enableStackdriverLogging":    getLogBool("enable_stackdriver_logging"),
            }
        }


        // --- Handle Messages ---
        // Check if messages exist and is a slice
        if msgs, ok := fulfillment["messages"].([]interface{}); ok {
            
            // Iterate over the messages slice
            for j, rawMsg := range msgs {
                msg, ok := rawMsg.(map[string]interface{})
                if !ok { continue }

                // Define the base path for this specific message in Terraform state
				msgTFPath := fmt.Sprintf("%s.messages.%d", baseFulfillmentPath, j)

				// 1. Response Type
				if val := d.Get(msgTFPath + ".response_type"); val != nil {
					if strVal, ok := val.(string); ok && strVal != "" {
						msg["responseType"] = strVal
					}
				}

				// 2. Tool Call
				// We get the map directly from d.Get
				if val := d.Get(msgTFPath + ".tool_call.0"); val != nil {
					
					// Cast directly to map[string]interface{} (No loop needed)
					if toolMap, ok := val.(map[string]interface{}); ok && len(toolMap) > 0 {
						
						// Create the destination map for the JSON payload
						newToolCall := make(map[string]interface{})

						// Extract fields directly from the Go map 'toolMap'
						// Note: We access keys using valid Terraform schema names (usually snake_case)

						// Action
						if action, ok := toolMap["action"].(string); ok && action != "" {
							newToolCall["action"] = action
						}

						// Tool
						if tool, ok := toolMap["tool"].(string); ok && tool != "" {
							newToolCall["tool"] = tool
						}

						// Input Parameters
						// 1. Get the raw string from the map (e.g. "{\"query\": \"...\"}")
						if inputParamsRaw, ok := toolMap["input_parameters"].(string); ok && inputParamsRaw != "" {
            
							var paramsMap map[string]interface{}
							
							// 2. Unmarshal the string into a Go map
							err := json.Unmarshal([]byte(inputParamsRaw), &paramsMap)
							
							// 3. If successful, assign it
							if err == nil && len(paramsMap) > 0 {
								newToolCall["inputParameters"] = paramsMap
							}
						}

						// Assign if we found valid data
						if len(newToolCall) > 0 {
							msg["toolCall"] = newToolCall
						}
					}
				}

				// 3. Knowledge Info Card
				// Get the map directly from Terraform state
				// Path example: handlers.0.event_handler.0.fulfillment.0.messages.0.knowledge_info_card.0
				if val := d.Get(msgTFPath + ".knowledge_info_card.0"); val != nil {
					
					// Cast directly to map[string]interface{}
					if cardMap, ok := val.(map[string]interface{}); ok && len(cardMap) > 0 {
						
						// Check if the specific key exists in the Go map
						if v, ok := cardMap["maximum_snippets"]; ok {
							
							// Assert that the value is an integer
							if maxSnip, ok := v.(int); ok {
								
								// Construct the JSON object (camelCase for API)
								msg["knowledgeInfoCard"] = map[string]interface{}{
									"maximumSnippets": maxSnip,
								}
							}
						}
					}
				}
            }
        }

		// --- Handle Conditional Cases ---
		if ccList, ok := fulfillment["conditionalCases"].([]interface{}); ok {
			
			// Loop 1: conditionalCases
			for k, rawCC := range ccList {
				ccMap, ok := rawCC.(map[string]interface{})
				if !ok { continue }

				if casesList, ok := ccMap["cases"].([]interface{}); ok {
					
					// Loop 2: cases
					for l, rawCase := range casesList {
						caseMap, ok := rawCase.(map[string]interface{})
						if !ok { continue }

						if contentList, ok := caseMap["caseContent"].([]interface{}); ok {
							
							// Loop 3: caseContent
							for m, rawContent := range contentList {
								contentMap, ok := rawContent.(map[string]interface{})
								if !ok { continue }

								// Check if this content block has a "message"
								if msgMap, ok := contentMap["message"].(map[string]interface{}); ok {
									
									// Construct the deep Terraform path
									// Format: ...conditional_cases.k.cases.l.case_content.m.message.0
									// Note: We use 'baseFulfillmentPath' which ends at "...fulfillment.0"
									msgTFPath := fmt.Sprintf("%s.conditional_cases.%d.cases.%d.case_content.%d.message.0", 
										baseFulfillmentPath, k, l, m)

									// --- Knowledge Info Card Logic (Same as before) ---
									// Path: ...message.0.knowledge_info_card.0
									if val := d.Get(msgTFPath + ".knowledge_info_card.0"); val != nil {
										
										// Treat knowledge_info_card as a Map
										if cardMap, ok := val.(map[string]interface{}); ok && len(cardMap) > 0 {
											
											// Extract maximum_snippets
											if v, ok := cardMap["maximum_snippets"]; ok {
												if maxSnip, ok := v.(int); ok {
													
													// Assign to the existing message map
													msgMap["knowledgeInfoCard"] = map[string]interface{}{
														"maximumSnippets": maxSnip,
													}
												}
											}
										}
									}

									// --- Tool Call (Same as before) ---
									// We get the map directly from d.Get
									if val := d.Get(msgTFPath + ".tool_call.0"); val != nil {
										
										// Cast directly to map[string]interface{} (No loop needed)
										if toolMap, ok := val.(map[string]interface{}); ok && len(toolMap) > 0 {
											
											// Create the destination map for the JSON payload
											newToolCall := make(map[string]interface{})

											// Extract fields directly from the Go map 'toolMap'
											// Note: We access keys using valid Terraform schema names (usually snake_case)

											// Action
											if action, ok := toolMap["action"].(string); ok && action != "" {
												newToolCall["action"] = action
											}

											// Tool
											if tool, ok := toolMap["tool"].(string); ok && tool != "" {
												newToolCall["tool"] = tool
											}

											// Input Parameters
											// 1. Get the raw string from the map (e.g. "{\"query\": \"...\"}")
											if inputParamsRaw, ok := toolMap["input_parameters"].(string); ok && inputParamsRaw != "" {
								
												var paramsMap map[string]interface{}
												
												// 2. Unmarshal the string into a Go map
												err := json.Unmarshal([]byte(inputParamsRaw), &paramsMap)
												
												// 3. If successful, assign it
												if err == nil && len(paramsMap) > 0 {
													newToolCall["inputParameters"] = paramsMap
												}
											}

											// Assign if we found valid data
											if len(newToolCall) > 0 {
												msgMap["toolCall"] = newToolCall
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
    }

    // Process both paths
    processSubHandler("eventHandler", "event_handler")
    processSubHandler("lifecycleHandler", "lifecycle_handler")
}

return res, nil
