var v interface{}
var ok bool

v, ok = res["assignments"]
if !ok || v == nil {
    return nil, nil
}

switch v.(type) {
case []interface{}:
    break
case map[string]interface{}:
    // Construct list out of single nested resource
    v = []interface{}{v}
default:
    return nil, fmt.Errorf("expected list or map for value assignments. Actual value: %v", v)
}

expectedName := d.Get("name")
expectedShortName := tpgresource.GetResourceNameFromSelfLink(expectedName.(string))

// Search list for this resource.
for _, itemRaw := range v.([]interface{}) {
    if itemRaw == nil {
        continue
    }
    item := itemRaw.(map[string]interface{})

    itemShortName := tpgresource.GetResourceNameFromSelfLink(item["name"].(string))
    // IsEmptyValue check so that if one is nil and the other is "", that's considered a match
    if !(tpgresource.IsEmptyValue(reflect.ValueOf(itemShortName)) && tpgresource.IsEmptyValue(reflect.ValueOf(expectedShortName))) && !reflect.DeepEqual(itemShortName, expectedShortName) {
        log.Printf("[DEBUG] Skipping item with name= %#v, looking for %#v)", itemShortName, expectedShortName)
        continue
    }
    log.Printf("[DEBUG] Found item for resource %q: %#v)", d.Id(), item)
    return item, nil
}
return nil, nil