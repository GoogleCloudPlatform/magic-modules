package {{ lower $.ProductMetadata.Name }}

import (

    "fmt"
    "log"
    "reflect"
{{- if and (not $.Immutable) ($.UpdateMask) }}
    "strings"
{{- end }}
    "time"

{{/*     # We list all the v2 imports here, because we run 'goimports' to guess the correct */}}
{{/*     # set of imports, which will never guess the major version correctly. */}}
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/acctest"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
    "github.com/hashicorp/terraform-plugin-sdk/v2/terraform"
    "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"

    "{{/* ##TODO: importpath() method/attribute ## -*/}}/tpgresource"
    transport_tpg "{{/* ##TODO: importpath() method/attribute ## -*/}}/transport"
    "{{/* ##TODO: importpath() method/attribute ## -*/}}/verify"

{{ if $.FlattenedProperties }}
    "google.golang.org/api/googleapi"
{{- end}}
)

{{if $.CustomCode.Constants}} //TODO Q2 function to compile constants custom code lines {{- end}}

func Resource{{ $.ResourceName -}}() *schema.Resource {
    return &schema.Resource{
        Create: resource{{ $.ResourceName -}}Create,
        Read: resource{{ $.ResourceName -}}Read,
{{- if $.Updatable -}}                                           {{/* ##TODO Q2 || $.root_labels? -}} */}}
        Update: resource{{ $.ResourceName -}}Update,
{{- end}}
        Delete: resource{{ $.ResourceName -}}Delete,

{{-  if not $.ExcludeImport }}

        Importer: &schema.ResourceImporter{
            State: resource{{ $.ResourceName -}}Import,
        },
{{- end}}

        Timeouts: &schema.ResourceTimeout {
            Create: schema.DefaultTimeout({{ $.Timeouts.InsertMinutes -}} * time.Minute),
{{- if $.Updatable -}}                                           {{/* ##TODO Q2 || $.root_labels? -}} */}}
            Update: schema.DefaultTimeout({{ $.Timeouts.UpdateMinutes -}} * time.Minute),
{{- end}}
            Delete: schema.DefaultTimeout({{ $.Timeouts.DeleteMinutes -}} * time.Minute),
        },

{{- if $.SchemaVersion }}
        SchemaVersion: {{ $.SchemaVersion -}},
{{- end}}
{{- if $.MigrateState }}
        MigrateState: {{ $.MigrateState -}},
{{- end}}
{{- if $.StateUpgraders }}

        StateUpgraders: []schema.StateUpgrader{
{{-       range $v := $.SchemaVersions }}
          {
            Type:    resource{{$.PathType}}ResourceV{{$v}}().CoreConfigSchema().ImpliedType(),
            Upgrade: Resource{{$.PathType}}UpgradeV{{$v}},
            Version: {{$v}},
          },
{{-       end }}
        },
{{- end }}
{{if or (and (or $.HasProject $.HasRegion $.HasZone) (not $.SkipDefaultCdiff)) $.CustomDiff }}
        CustomizeDiff: customdiff.All(
{{- if $.CustomDiff -}}
{{-          range $cdiff := $.CustomDiff -}}
        {{ $cdiff }},
{{- end}}
{{- end}}
{{- if and ($.HasProject) (not $.SkipDefaultCdiff) }}
            tpgresource.DefaultProviderProject,
{{- end -}}
{{if and ($.HasRegion) (not $.SkipDefaultCdiff)  }}
            tpgresource.DefaultProviderRegion,
{{- end -}}
{{if and ($.HasZone) (not $.SkipDefaultCdiff)  }}
            tpgresource.DefaultProviderZone,
{{- end }}
        ),
{{- end}}

{{- if $.DeprecationMessage }}
        DeprecationMessage: "{{ $.DeprecationMessage -}}",
{{- end}}

        Schema: map[string]*schema.Schema{
//TODO order props?
			{{- range $prop := $.AllUserProperties }}
{{template "SchemaFields" $prop -}}
			{{- end }}
{{- if $.VirtualFields -}}
{{-   range $field := $.VirtualFields }}
            "{{ $field.Name -}}": {
                Type: schema.{{ $field.ItemType -}},
                Optional: true,
{{      if $field.Immutable -}}
                ForceNew: true,
{{-     end}}
{{      if $field.DefaultValue -}}
                Default:  {{ $field.Default_Value -}},
{{-     end}}
                Description: `{{ $field.Description -}}`,
            },
{{-   end}}
{{- end}}
 //TODO Q2 function to compile custom code lines ($.CustomCode.extra_schema_entry)
{{- if $.HasProject }}
            "project": {
                Type:     schema.TypeString,
                Optional: true,
                Computed: true,
                ForceNew: true,
            },
{{- end}}
{{if $.HasSelfLink -}}
            "self_link": {
                Type:     schema.TypeString,
                Computed: true,
            },
{{- end}}
        },
        UseJSONNumber: true,
    }
}

{{- range $prop := $.AllUserProperties }}
{{if and (eq $prop.Type "Array") ($prop.IsSet) (eq $prop.ItemType "NestedObject")}}
{{template "SchemaSubResource" $prop}}
{{end}}
{{- end}}

func resource{{ $.ResourceName -}}Create(d *schema.ResourceData, meta interface{}) error {
{{if and ($.GetAsync.IsA "OpAsync") ($.GetAsync.IncludeProject) ($.GetAsync.Allow "Create") -}}
    var project string
{{- end}}
    config := meta.(*transport_tpg.Config)
{{if $.CustomCode.CustomCreate -}}
 //TODO Q2 function to compile custom code lines
{{  else  -}}
    userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
    if err != nil {
        return err
    }

    obj := make(map[string]interface{})

{{- range $prop := $.SettableProperties }}
    {{ $prop.ApiName -}}Prop, err := expand{{ if $.NestedQuery -}}Nested{{ end }}{{ $.ResourceName -}}{{ camelize $prop.Name "upper" -}}({{ if $prop.FlattenObject }}nil{{ else }}d.Get("{{ underscore $prop.Name }}{{ end }}"), d, config)
    if err != nil {
        return err
{{if $prop.SendEmptyValue -}}
    } else if v, ok := d.GetOkExists("{{ underscore $prop.Name -}}"); ok || !reflect.DeepEqual(v, {{ $prop.ApiName -}}Prop) {
{{      else if $prop.FlattenObject -}}
    } else if !tpgresource.IsEmptyValue(reflect.ValueOf({{ $prop.ApiName -}}Prop)) {
{{      else -}}
    } else if v, ok := d.GetOkExists("{{ underscore $prop.Name -}}"); !tpgresource.IsEmptyValue(reflect.ValueOf({{ $prop.ApiName -}}Prop)) && (ok || !reflect.DeepEqual(v, {{ $prop.ApiName -}}Prop)) {
{{- end}}
        obj["{{ $prop.ApiName -}}"] = {{ $prop.ApiName -}}Prop
    }
{{- end}}

{{if $.CustomCode.Encoder -}}
    obj, err = resource{{ $.ResourceName -}}Encoder(d, meta, obj)
    if err != nil {
        return err
    }
{{- end}}

{{if $.Mutex -}}
    lockName, err := tpgresource.ReplaceVars(d, config, "{{ $.Mutex -}}")
    if err != nil {
        return err
    }
    transport_tpg.MutexStore.Lock(lockName)
    defer transport_tpg.MutexStore.Unlock(lockName)
{{- end}}

    url, err := tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{"{{"}}{{$.ProductMetadata.Name}}BasePath{{"}}"}}{{$.CreateUri}}")
    if err != nil {
        return err
    }

    log.Printf("[DEBUG] Creating new {{ $.Name -}}: %#v", obj)
{{if $.NestedQuery -}}
{{if $.NestedQuery.ModifyByPatch }}
{{/*# Keep this after mutex - patch request data relies on current resource state */}}
    obj, err = resource{{ $.ResourceName -}}PatchCreateEncoder(d, meta, obj)
    if err != nil {
        return err
    }
{{if $.UpdateMask -}}
    url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": "{{ join $.NestedQuery.Keys "." -}}"})
    if err != nil {
        return err
    }
{{- end}}
{{- end}}
{{- end}}
    billingProject := ""

{{if $.HasProject -}}
    project, err := tpgresource.GetProject(d, config)
    if err != nil {
        return fmt.Errorf("Error fetching project for {{ $.Name -}}: %s", err)
    }
{{if $.LegacyLongFormProject -}}
    billingProject = strings.TrimPrefix(project, "projects/")
{{      else -}}
    billingProject = project
{{- end}}
{{- end}}

{{if $.SupportsIndirectUserProjectOverride -}}
    if parts := regexp.MustCompile(`projects\/([^\/]+)\/`).FindStringSubmatch(url); parts != nil {
        billingProject = parts[1]
    }
{{- end}}

    // err == nil indicates that the billing_project value was found
    if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
      billingProject = bp
    }

//TODO Q2 COMPILE PRECREATE
    res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
        Config: config,
        Method: "{{ upper $.CreateVerb -}}",
        Project: billingProject,
        RawURL: url,
        UserAgent: userAgent,
        Body: obj,
        Timeout: d.Timeout(schema.TimeoutCreate),
{{if $.ErrorRetryPredicates -}}
        ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorRetryPredicates "," -}}{{"}"}},
{{- end}}
{{if $.ErrorAbortPredicates -}}
        ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{ join $.ErrorAbortPredicates "," -}}{{"}"}},
{{- end}}
    })
    if err != nil {
{{if and ($.CustomCode.PostCreateFailure) ($.GetAsync) -}}
        resource{{ $.ResourceName -}}PostCreateFailure(d, meta)
{{- end}}
        return fmt.Errorf("Error creating {{ $.Name -}}: %s", err)
    }
{{/* # Set resource properties from create API response (unless it returns an Operation) */}}
{{if not ($.GetAsync.IsA "OpAsync") }}
{{- range $prop := $.GettableProperties }}
//todo does identities contain property
{{		if and (true) ($prop.Output)}}
    if err := d.Set("{{ underscore $prop.Name -}}", flatten{{ if $.NestedQuery -}}Nested{{end}}{{ $.ResourceName -}}{{ camelize $prop.Name "upper"  -}}(res["{{ $prop.ApiName -}}"], d, config)); err != nil {
        return fmt.Errorf(`Error setting computed identity field "{{ underscore $prop.Name }}": %s`, err)
    }
{{- end}}
{{- end}}
{{- end}}

    // Store the ID now
    id, err := tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{ $.IdFormat -}}")
    if err != nil {
        return fmt.Errorf("Error constructing id: %s", err)
    }
    d.SetId(id)

{{if ($.GetAsync.Allow "Create") -}}
{{if ($.GetAsync.IsA "OpAsync") -}}
{{if and $.GetAsync.Result.ResourceInsideResponse $.GetIdentity -}}
    // Use the resource in the operation response to populate
    // identity fields and d.Id() before read
    var opRes map[string]interface{}
    err = {{ $.ClientNamePascal -}}OperationWaitTimeWithResponse(
    config, res, &opRes, {{if or $.HasProject $.GetAsync.IncludeProject -}} {{if $.LegacyLongFormProject -}}tpgresource.GetResourceNameFromSelfLink(project){{ else }}project{{ end }}, {{ end -}} "Creating {{ $.Name -}}", userAgent,
        d.Timeout(schema.TimeoutCreate))
    if err != nil {
{{if $.CustomCode.PostCreateFailure -}}
        resource{{ $.ResourceName -}}PostCreateFailure(d, meta)
{{- end}}
{{-          if not $.TaintResourceOnFailedCreate -}}
        // The resource didn't actually create
        d.SetId("")

{{- end}}
        return fmt.Errorf("Error waiting to create {{ $.Name -}}: %s", err)
    }

{{if $.CustomCode.Decoder -}}
    opRes, err = resource{{ $.ResourceName -}}Decoder(d, meta, opRes)
    if err != nil {
        return fmt.Errorf("Error decoding response from operation: %s", err)
    }
    if opRes == nil {
        return fmt.Errorf("Error decoding response from operation, could not find $")
    }
{{- end}}

{{if $.NestedQuery -}}
{{if $.NestedQuery.Keys -}}
    if _, ok := opRes["{{ index $.NestedQuery.Keys 0 -}}"]; ok {
        opRes, err = flattenNested{{ $.ResourceName -}}(d, meta, opRes)
        if err != nil {
            return fmt.Errorf("Error getting nested $ from operation response: %s", err)
        }
        if opRes == nil {
            // Object isn't there any more - remove it from the state.
            return fmt.Errorf("Error decoding response from operation, could not find nested $")
        }
    }
{{- end}}
{{- range $prop := $.GettableProperties }}
//todo does identities contain property
{{		if and (true) ($prop.Output)}}
    if err := d.Set("{{ underscore $prop.Name -}}", flatten{{ if $.NestedQuery -}}Nested{{ end }}{{ $.ResourceName -}}{{ camelize $prop.Name "upper"  -}}(opRes["{{ $prop.ApiName -}}"], d, config)); err != nil {
        return err
    }
{{- end}}
{{- end}}
{{- end}}

    // This may have caused the ID to update - update it if so.
    id, err = tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{ $.IdFormat -}}")
    if err != nil {
        return fmt.Errorf("Error constructing id: %s", err)
    }
    d.SetId(id)

{{        else -}}
    err = {{ $.ClientNamePascal -}}OperationWaitTime(
    config, res, {{if or $.Project $.GetAsync.IncludeProject -}} {{if $.LegacyLongFormProject -}}tpgresource.GetResourceNameFromSelfLink(project){{ else }}project{{ end }}, {{ end -}} "Creating {{ $.Name -}}", userAgent,
        d.Timeout(schema.TimeoutCreate))

    if err != nil {
{{if $.CustomCode.PostCreateFailure -}}
        resource{{ $.ResourceName -}}PostCreateFailure(d, meta)
{{- end}}
{{          if not $.TaintResourceOnFailedCreate -}}
        // The resource didn't actually create
        d.SetId("")
{{- end}}
        return fmt.Errorf("Error waiting to create {{ $.Name -}}: %s", err)
    }

{{        end  -}}
{{      end -}}
{{    end -}}

//TODO POST CREATE

{{if $.GetAsync.Allow "Create" -}}
{{if $.GetAsync.IsA "PollAsync" -}}
    err = transport_tpg.PollingWaitTime(resource{{ $.ResourceName -}}PollRead(d, meta), {{ $.GetAsync.CheckResponseFuncExistence -}}, "Creating {{ $.Name -}}", d.Timeout(schema.TimeoutCreate), {{ $.GetAsync.TargetOccurrences -}})
    if err != nil {
{{if $.GetAsync.SuppressError -}}
        log.Printf("[ERROR] Unable to confirm eventually consistent {{ $.Name -}} %q finished updating: %q", d.Id(), err)
{{        else -}}
{{if $.CustomCode.PostCreateFailure -}}
        resource{{ $.ResourceName -}}PostCreateFailure(d, meta)
{{- end}}
        return fmt.Errorf("Error waiting to create {{ $.Name -}}: %s", err)
{{- end}}
    }

{{- end}}
{{- end}}

    log.Printf("[DEBUG] Finished creating {{ $.Name -}} %q: %#v", d.Id(), res)

    return resource{{ $.ResourceName -}}Read(d, meta)
{{  end -}}
}

{{if ($.GetAsync.IsA "OpAsync")}}
func resource{{ $.ResourceName -}}PollRead(d *schema.ResourceData, meta interface{}) transport_tpg.PollReadFunc {
    return func() (map[string]interface{}, error) {
{{if $.GetAsync.CustomPollRead -}}
//TODO custom poll read
{{    else -}}
        config := meta.(*transport_tpg.Config)


        url, err := tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{"{{"}}{{$.ProductMetadata.Name}}BasePath{{"}}"}}/{{$.SelfLinkUri}}")

        if err != nil {
            return nil, err
        }

        billingProject := ""

{{if $.HasProject -}}
        project, err := tpgresource.GetProject(d, config)
        if err != nil {
            return nil, fmt.Errorf("Error fetching project for {{ $.Name -}}: %s", err)
        }
{{if $.LegacyLongFormProject -}}
        billingProject = strings.TrimPrefix(project, "projects/")
{{        else -}}
        billingProject = project
{{- end}}
{{- end}}

{{if $.SupportsIndirectUserProjectOverride -}}
        if parts := regexp.MustCompile(`projects\/([^\/]+)\/`).FindStringSubmatch(url); parts != nil {
            billingProject = parts[1]
        }
{{- end}}

        // err == nil indicates that the billing_project value was found
        if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
        billingProject = bp
        }

        userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
        if err != nil {
            return nil, err
        }

        res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
            Config: config,
            Method: "{{ upper $.ReadVerb -}}",
            Project: billingProject,
            RawURL: url,
            UserAgent: userAgent,
{{if $.ErrorRetryPredicates -}}
            ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorRetryPredicates "," -}}{{"}"}},
{{- end}}
{{if $.ErrorAbortPredicates -}}
            ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorRetryPredicates "," -}}{{"}"}},
{{- end}}
        })
        if err != nil {
            return res, err
        }
{{if $.NestedQuery -}}
        res, err = flattenNested{{ $.ResourceName -}}(d, meta, res)
        if err != nil {
            return nil, err
        }

        if res == nil {
            return nil, tpgresource.Fake404("nested", "{{ $.ResourceName }}")
        }

{{- end}}
{{if $.CustomCode.Decoder -}}
        res, err = resource{{ $.ResourceName -}}Decoder(d, meta, res)
        if err != nil {
            return nil, err
        }
        if res == nil {
            return nil, tpgresource.Fake404("decoded", "{{ $.ResourceName }}")
        }

{{- end}}
        return res, nil
{{    end  -}}
    }
}
{{  end -}}

func resource{{ $.ResourceName -}}Read(d *schema.ResourceData, meta interface{}) error {
{{if $.SkipRead -}}
  // This resource could not be read from the API.
  return nil
{{  else  -}}
    config := meta.(*transport_tpg.Config)
    userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
    if err != nil {
        return err
    }

    url, err := tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{"{{"}}{{$.ProductMetadata.Name}}BasePath{{"}}"}}/{{$.SelfLinkUri}}{{$.ReadQueryParams}}")
    if err != nil {
        return err
    }

    billingProject := ""

{{if $.HasProject -}}
    project, err := tpgresource.GetProject(d, config)
    if err != nil {
        return fmt.Errorf("Error fetching project for {{ $.Name -}}: %s", err)
    }
{{if $.LegacyLongFormProject -}}
    billingProject = strings.TrimPrefix(project, "projects/")
{{    else -}}
    billingProject = project
{{- end}}
{{- end}}

{{if $.SupportsIndirectUserProjectOverride -}}
    if parts := regexp.MustCompile(`projects\/([^\/]+)\/`).FindStringSubmatch(url); parts != nil {
        billingProject = parts[1]
    }
{{- end}}

    // err == nil indicates that the billing_project value was found
    if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
      billingProject = bp
    }

    headers := make(http.Header)
    {{ if $.CustomCode.PreRead -}}
    //todo preread
    {{ end }}
    res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
        Config: config,
        Method: "{{ upper $.ReadVerb -}}",
        Project: billingProject,
        RawURL: url,
        UserAgent: userAgent,
{{if $.ErrorRetryPredicates -}}
        ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorRetryPredicates "," -}}{{"}"}},
{{- end}}
{{if $.ErrorAbortPredicates -}}
        ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorRetryPredicates "," -}}{{"}"}},
{{- end}}
    })
    if err != nil {
{{if $.ReadErrorTransform -}}
        return transport_tpg.HandleNotFoundError({{ $.ReadErrorTransform }}(err), d, fmt.Sprintf("{{ $.ResourceName -}} %q", d.Id()))
{{  else -}}
        return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("{{ $.ResourceName -}} %q", d.Id()))
{{- end}}
    }

{{if $.NestedQuery -}}
    res, err = flattenNested{{ $.ResourceName -}}(d, meta, res)
    if err != nil {
        return err
    }

    if res == nil {
        // Object isn't there any more - remove it from the state.
        log.Printf("[DEBUG] Removing {{ $.ResourceName -}} because it couldn't be matched.")
        d.SetId("")
        return nil
    }

{{- end}}

{{if $.CustomCode.Decoder -}}
    res, err = resource{{ $.ResourceName -}}Decoder(d, meta, res)
    if err != nil {
        return err
    }

    if res == nil {
        // Decoding the $ has resulted in it being gone. It may be marked deleted
        log.Printf("[DEBUG] Removing {{ $.ResourceName -}} because it no longer exists.")
        d.SetId("")
        return nil
    }

{{- end}}
{{- if $.VirtualFields -}}
  // Explicitly set virtual fields to default values if unset
{{- range $prop := $.VirtualFields }}
{{      if $prop.DefaultValue -}}
    if _, ok := d.GetOkExists("{{ $prop.Name -}}"); !ok {
        if err := d.Set("{{ $prop.Name -}}", {{ $prop.DefaultValue -}}); err != nil {
            return fmt.Errorf("Error setting {{ $prop.Name -}}: %s", err)
        }
    }
{{- end}}
{{- end}}
{{- end}}
{{if $.HasProject -}}
    if err := d.Set("project", project); err != nil {
        return fmt.Errorf("Error reading {{ $.Name -}}: %s", err)
    }
{{- end}}

{{if $.HasRegion -}}
    region, err := tpgresource.GetRegion(d, config)
    if err != nil {
        return err
    }
    if err := d.Set("region", region); err != nil {
        return fmt.Errorf("Error reading {{ $.Name -}}: %s", err)
    }
{{- end}}

{{if $.HasZone -}}
    zone, err := tpgresource.GetZone(d, config)
    if err != nil {
        return err
    }
    if err := d.Set("zone", zone); err != nil {
        return fmt.Errorf("Error reading {{ $.Name -}}: %s", err)
    }
{{- end}}

{{- range $prop := $.ReadProperties }}
{{if $prop.FlattenObject -}}
// Terraform must set the top level schema field, but since this $ contains collapsed properties
// it's difficult to know what the top level should be. Instead we just loop over the map returned from flatten.
    if flattenedProp := flatten{{ if $.NestedQuery -}}Nested{{end}}{{ $.ResourceName -}}{{ camelize $prop.Name "upper"  -}}(res["{{ $prop.ApiName -}}"], d, config); flattenedProp != nil {
        if gerr, ok := flattenedProp.(*googleapi.Error); ok {
            return fmt.Errorf("Error reading {{ $.Name -}}: %s", gerr)
        }
        casted := flattenedProp.([]interface{})[0]
        if casted != nil {
            for k, v := range casted.(map[string]interface{}) {
                if err := d.Set(k, v); err != nil {
                    return fmt.Errorf("Error setting %s: %s", k, err)
                }
            }
        }
    }
{{    else -}}
    if err := d.Set("{{ underscore $prop.Name -}}", flatten{{ if $.NestedQuery -}}Nested{{end}}{{ $.ResourceName -}}{{ camelize $prop.Name "upper" -}}(res["{{ $prop.ApiName -}}"], d, config)); err != nil {
        return fmt.Errorf("Error reading {{ $.Name -}}: %s", err)
    }
{{- end}}
{{- end}}
{{if $.HasSelfLink -}}
    if err := d.Set("self_link", tpgresource.ConvertSelfLinkToV1(res["selfLink"].(string))); err != nil {
        return fmt.Errorf("Error reading {{ $.Name -}}: %s", err)
    }
{{- end}}

    return nil
{{  end -}}
}
