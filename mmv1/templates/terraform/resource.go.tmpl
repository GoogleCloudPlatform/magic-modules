{{/* the license inside this block applies to this file
  Copyright 2024 Google LLC. All Rights Reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License. */}}
// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package {{ lower $.ProductMetadata.Name }}

import (

    "fmt"
    "log"
    "reflect"
{{- if and (not $.Immutable) ($.UpdateMask) }}
    "strings"
{{- end }}
    "time"

{{/*     # We list all the v2 imports here, because we run 'goimports' to guess the correct */}}
{{/*     # set of imports, which will never guess the major version correctly. */}}
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/acctest"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
    "github.com/hashicorp/terraform-plugin-sdk/v2/terraform"
    "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"

    "{{/* ##TODO: importpath() method/attribute ## -*/}}/tpgresource"
    transport_tpg "{{/* ##TODO: importpath() method/attribute ## -*/}}/transport"
    "{{/* ##TODO: importpath() method/attribute ## -*/}}/verify"

{{ if $.FlattenedProperties }}
    "google.golang.org/api/googleapi"
{{- end}}
)

{{if $.CustomCode.Constants}} //TODO Q2 function to compile constants custom code lines {{- end}}

func Resource{{ $.ResourceName -}}() *schema.Resource {
    return &schema.Resource{
        Create: resource{{ $.ResourceName -}}Create,
        Read: resource{{ $.ResourceName -}}Read,
{{- if $.Updatable -}}                                           {{/* ##TODO Q2 || $.root_labels? -}} */}}
        Update: resource{{ $.ResourceName -}}Update,
{{- end}}
        Delete: resource{{ $.ResourceName -}}Delete,

{{-  if not $.ExcludeImport }}

        Importer: &schema.ResourceImporter{
            State: resource{{ $.ResourceName -}}Import,
        },
{{- end}}

        Timeouts: &schema.ResourceTimeout {
            Create: schema.DefaultTimeout({{ $.Timeouts.InsertMinutes -}} * time.Minute),
{{- if $.Updatable -}}                                           {{/* ##TODO Q2 || $.root_labels? -}} */}}
            Update: schema.DefaultTimeout({{ $.Timeouts.UpdateMinutes -}} * time.Minute),
{{- end}}
            Delete: schema.DefaultTimeout({{ $.Timeouts.DeleteMinutes -}} * time.Minute),
        },

{{- if $.SchemaVersion }}
        SchemaVersion: {{ $.SchemaVersion -}},
{{- end}}
{{- if $.MigrateState }}
        MigrateState: {{ $.MigrateState -}},
{{- end}}
{{- if $.StateUpgraders }}

        StateUpgraders: []schema.StateUpgrader{
{{-       range $v := $.SchemaVersions }}
          {
            Type:    resource{{$.PathType}}ResourceV{{$v}}().CoreConfigSchema().ImpliedType(),
            Upgrade: Resource{{$.PathType}}UpgradeV{{$v}},
            Version: {{$v}},
          },
{{-       end }}
        },
{{- end }}
{{if or (and (or $.HasProject $.HasRegion $.HasZone) (not $.SkipDefaultCdiff)) $.CustomDiff }}
        CustomizeDiff: customdiff.All(
{{- if $.CustomDiff -}}
{{-          range $cdiff := $.CustomDiff -}}
        {{ $cdiff }},
{{- end}}
{{- end}}
{{- if and ($.HasProject) (not $.SkipDefaultCdiff) }}
            tpgresource.DefaultProviderProject,
{{- end -}}
{{if and ($.HasRegion) (not $.SkipDefaultCdiff)  }}
            tpgresource.DefaultProviderRegion,
{{- end -}}
{{if and ($.HasZone) (not $.SkipDefaultCdiff)  }}
            tpgresource.DefaultProviderZone,
{{- end }}
        ),
{{- end}}

{{- if $.DeprecationMessage }}
        DeprecationMessage: "{{ $.DeprecationMessage -}}",
{{- end}}

        Schema: map[string]*schema.Schema{
//TODO order props?
			{{- range $prop := $.AllUserProperties }}
{{template "SchemaFields" $prop -}}
			{{- end }}
{{- if $.VirtualFields -}}
{{-   range $field := $.VirtualFields }}
            "{{ $field.Name -}}": {
                Type: schema.{{ $field.ItemType -}},
                Optional: true,
{{      if $field.Immutable -}}
                ForceNew: true,
{{-     end}}
{{      if $field.DefaultValue -}}
                Default:  {{ $field.Default_Value -}},
{{-     end}}
                Description: `{{ $field.Description -}}`,
            },
{{-   end}}
{{- end}}
 //TODO Q2 function to compile custom code lines ($.CustomCode.extra_schema_entry)
{{- if $.HasProject }}
            "project": {
                Type:     schema.TypeString,
                Optional: true,
                Computed: true,
                ForceNew: true,
            },
{{- end}}
{{if $.HasSelfLink -}}
            "self_link": {
                Type:     schema.TypeString,
                Computed: true,
            },
{{- end}}
        },
        UseJSONNumber: true,
    }
}

{{- range $prop := $.AllUserProperties }}
{{if and (eq $prop.Type "Array") ($prop.IsSet) (eq $prop.ItemType "NestedObject")}}
{{template "SchemaSubResource" $prop}}
{{end}}
{{- end}}

func resource{{ $.ResourceName -}}Create(d *schema.ResourceData, meta interface{}) error {
{{if and ($.GetAsync.IsA "OpAsync") ($.GetAsync.IncludeProject) ($.GetAsync.Allow "Create") -}}
    var project string
{{- end}}
    config := meta.(*transport_tpg.Config)
{{if $.CustomCode.CustomCreate -}}
 //TODO Q2 function to compile custom code lines
{{  else  -}}
    userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
    if err != nil {
        return err
    }

    obj := make(map[string]interface{})

{{- range $prop := $.SettableProperties }}
    {{ $prop.ApiName -}}Prop, err := expand{{ if $.NestedQuery -}}Nested{{ end }}{{ $.ResourceName -}}{{ camelize $prop.Name "upper" -}}({{ if $prop.FlattenObject }}nil{{ else }}d.Get("{{ underscore $prop.Name }}{{ end }}"), d, config)
    if err != nil {
        return err
{{if $prop.SendEmptyValue -}}
    } else if v, ok := d.GetOkExists("{{ underscore $prop.Name -}}"); ok || !reflect.DeepEqual(v, {{ $prop.ApiName -}}Prop) {
{{      else if $prop.FlattenObject -}}
    } else if !tpgresource.IsEmptyValue(reflect.ValueOf({{ $prop.ApiName -}}Prop)) {
{{      else -}}
    } else if v, ok := d.GetOkExists("{{ underscore $prop.Name -}}"); !tpgresource.IsEmptyValue(reflect.ValueOf({{ $prop.ApiName -}}Prop)) && (ok || !reflect.DeepEqual(v, {{ $prop.ApiName -}}Prop)) {
{{- end}}
        obj["{{ $prop.ApiName -}}"] = {{ $prop.ApiName -}}Prop
    }
{{- end}}

{{if $.CustomCode.Encoder -}}
    obj, err = resource{{ $.ResourceName -}}Encoder(d, meta, obj)
    if err != nil {
        return err
    }
{{- end}}

{{if $.Mutex -}}
    lockName, err := tpgresource.ReplaceVars(d, config, "{{ $.Mutex -}}")
    if err != nil {
        return err
    }
    transport_tpg.MutexStore.Lock(lockName)
    defer transport_tpg.MutexStore.Unlock(lockName)
{{- end}}

    url, err := tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{"{{"}}{{$.ProductMetadata.Name}}BasePath{{"}}"}}{{$.CreateUri}}")
    if err != nil {
        return err
    }

    log.Printf("[DEBUG] Creating new {{ $.Name -}}: %#v", obj)
{{if $.NestedQuery.ModifyByPatch -}}
{{/*# Keep this after mutex - patch request data relies on current resource state */}}
    obj, err = resource{{ $.ResourceName -}}PatchCreateEncoder(d, meta, obj)
    if err != nil {
        return err
    }
{{if $.UpdateMask -}}
    url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": "{{ join $.NestedQuery.Keys "." -}}"})
    if err != nil {
        return err
    }
{{- end}}
{{- end}}
    billingProject := ""

{{if $.HasProject -}}
    project, err := tpgresource.GetProject(d, config)
    if err != nil {
        return fmt.Errorf("Error fetching project for {{ $.Name -}}: %s", err)
    }
{{if $.LegacyLongFormProject -}}
    billingProject = strings.TrimPrefix(project, "projects/")
{{      else -}}
    billingProject = project
{{- end}}
{{- end}}

{{if $.SupportsIndirectUserProjectOverride -}}
    if parts := regexp.MustCompile(`projects\/([^\/]+)\/`).FindStringSubmatch(url); parts != nil {
        billingProject = parts[1]
    }
{{- end}}

    // err == nil indicates that the billing_project value was found
    if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
      billingProject = bp
    }

//TODO Q2 COMPILE PRECREATE
    res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
        Config: config,
        Method: "{{ upper $.CreateVerb -}}",
        Project: billingProject,
        RawURL: url,
        UserAgent: userAgent,
        Body: obj,
        Timeout: d.Timeout(schema.TimeoutCreate),
{{if $.ErrorRetryPredicates -}}
        ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorRetryPredicates "," -}}{{"}"}},
{{- end}}
{{if $.ErrorAbortPredicates -}}
        ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{ join $.ErrorAbortPredicates "," -}}{{"}"}},
{{- end}}
    })
    if err != nil {
{{if and ($.CustomCode.PostCreateFailure) ($.GetAsync) -}}
        resource{{ $.ResourceName -}}PostCreateFailure(d, meta)
{{- end}}
        return fmt.Errorf("Error creating {{ $.Name -}}: %s", err)
    }
{{/* # Set resource properties from create API response (unless it returns an Operation) */}}
{{if not ($.GetAsync.IsA "OpAsync") }}
{{- range $prop := $.GettableProperties }}
//todo does identities contain property
{{		if and (true) ($prop.Output)}}
    if err := d.Set("{{ underscore $prop.Name -}}", flatten{{ if $.NestedQuery -}}Nested{{end}}{{ $.ResourceName -}}{{ camelize $prop.Name "upper"  -}}(res["{{ $prop.ApiName -}}"], d, config)); err != nil {
        return fmt.Errorf(`Error setting computed identity field "{{ underscore $prop.Name }}": %s`, err)
    }
{{- end}}
{{- end}}
{{- end}}

    // Store the ID now
    id, err := tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{ $.IdFormat -}}")
    if err != nil {
        return fmt.Errorf("Error constructing id: %s", err)
    }
    d.SetId(id)

{{if ($.GetAsync.Allow "Create") -}}
{{if ($.GetAsync.IsA "OpAsync") -}}
{{if and $.GetAsync.Result.ResourceInsideResponse $.GetIdentity -}}
    // Use the resource in the operation response to populate
    // identity fields and d.Id() before read
    var opRes map[string]interface{}
    err = {{ $.ClientNamePascal -}}OperationWaitTimeWithResponse(
    config, res, &opRes, {{if or $.HasProject $.GetAsync.IncludeProject -}} {{if $.LegacyLongFormProject -}}tpgresource.GetResourceNameFromSelfLink(project){{ else }}project{{ end }}, {{ end -}} "Creating {{ $.Name -}}", userAgent,
        d.Timeout(schema.TimeoutCreate))
    if err != nil {
{{if $.CustomCode.PostCreateFailure -}}
        resource{{ $.ResourceName -}}PostCreateFailure(d, meta)
{{- end}}
{{-          if not $.TaintResourceOnFailedCreate -}}
        // The resource didn't actually create
        d.SetId("")

{{- end}}
        return fmt.Errorf("Error waiting to create {{ $.Name -}}: %s", err)
    }

{{if $.CustomCode.Decoder -}}
    opRes, err = resource{{ $.ResourceName -}}Decoder(d, meta, opRes)
    if err != nil {
        return fmt.Errorf("Error decoding response from operation: %s", err)
    }
    if opRes == nil {
        return fmt.Errorf("Error decoding response from operation, could not find $")
    }
{{- end}}

{{if $.NestedQuery.Keys -}}
    if _, ok := opRes["{{ index $.NestedQuery.Keys 0 -}}"]; ok {
        opRes, err = flattenNested{{ $.ResourceName -}}(d, meta, opRes)
        if err != nil {
            return fmt.Errorf("Error getting nested $ from operation response: %s", err)
        }
        if opRes == nil {
            // Object isn't there any more - remove it from the state.
            return fmt.Errorf("Error decoding response from operation, could not find nested $")
        }
    }
{{- end}}
{{- range $prop := $.GettableProperties }}
//todo does identities contain property
{{		if and (true) ($prop.Output)}}
    if err := d.Set("{{ underscore $prop.Name -}}", flatten{{ if $.NestedQuery -}}Nested{{ end }}{{ $.ResourceName -}}{{ camelize $prop.Name "upper"  -}}(opRes["{{ $prop.ApiName -}}"], d, config)); err != nil {
        return err
    }
{{- end}}
{{- end}}

    // This may have caused the ID to update - update it if so.
    id, err = tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{ $.IdFormat -}}")
    if err != nil {
        return fmt.Errorf("Error constructing id: %s", err)
    }
    d.SetId(id)

{{        else -}}
    err = {{ $.ClientNamePascal -}}OperationWaitTime(
    config, res, {{if or $.Project $.GetAsync.IncludeProject -}} {{if $.LegacyLongFormProject -}}tpgresource.GetResourceNameFromSelfLink(project){{ else }}project{{ end }}, {{ end -}} "Creating {{ $.Name -}}", userAgent,
        d.Timeout(schema.TimeoutCreate))

    if err != nil {
{{if $.CustomCode.PostCreateFailure -}}
        resource{{ $.ResourceName -}}PostCreateFailure(d, meta)
{{- end}}
{{          if not $.TaintResourceOnFailedCreate -}}
        // The resource didn't actually create
        d.SetId("")
{{- end}}
        return fmt.Errorf("Error waiting to create {{ $.Name -}}: %s", err)
    }

{{        end  -}}
{{      end -}}
{{    end -}}

//TODO POST CREATE

{{if $.GetAsync.Allow "Create" -}}
{{if $.GetAsync.IsA "PollAsync" -}}
    err = transport_tpg.PollingWaitTime(resource{{ $.ResourceName -}}PollRead(d, meta), {{ $.GetAsync.CheckResponseFuncExistence -}}, "Creating {{ $.Name -}}", d.Timeout(schema.TimeoutCreate), {{ $.GetAsync.TargetOccurrences -}})
    if err != nil {
{{if $.GetAsync.SuppressError -}}
        log.Printf("[ERROR] Unable to confirm eventually consistent {{ $.Name -}} %q finished updating: %q", d.Id(), err)
{{        else -}}
{{if $.CustomCode.PostCreateFailure -}}
        resource{{ $.ResourceName -}}PostCreateFailure(d, meta)
{{- end}}
        return fmt.Errorf("Error waiting to create {{ $.Name -}}: %s", err)
{{- end}}
    }

{{- end}}
{{- end}}

    log.Printf("[DEBUG] Finished creating {{ $.Name -}} %q: %#v", d.Id(), res)

    return resource{{ $.ResourceName -}}Read(d, meta)
{{  end -}}
}
