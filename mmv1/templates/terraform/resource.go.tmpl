{{/* The license inside this block applies to this file
  Copyright 2024 Google LLC. All Rights Reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License. */ -}}
// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

{{$.CodeHeader TemplatePath}}

package {{ lower $.ProductMetadata.Name }}

import (

    "fmt"
    "log"
    "net/http"
    "reflect"
{{- if $.SupportsIndirectUserProjectOverride }}
    "regexp"
{{- end }}
{{- if or (and (not $.Immutable) ($.UpdateMask)) $.LegacyLongFormProject }}
    "strings"
{{- end }}
    "time"

{{/*     # We list all the v2 imports here, because we run 'goimports' to guess the correct */}}
{{/*     # set of imports, which will never guess the major version correctly. */}}
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/acctest"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
    "github.com/hashicorp/terraform-plugin-sdk/v2/terraform"
    "github.com/hashicorp/terraform-plugin-sdk/v2/diag"
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
    "github.com/hashicorp/go-cty/cty"

    "{{ $.ImportPath }}/tpgresource"
    transport_tpg "{{ $.ImportPath }}/transport"
    "{{ $.ImportPath }}/verify"

{{ if $.FlattenedProperties }}
    "google.golang.org/api/googleapi"
{{- end}}
)

{{if $.CustomCode.Constants -}} 
    {{- $.CustomTemplate $.CustomCode.Constants true -}}
{{- end}}

func Resource{{ $.ResourceName -}}() *schema.Resource {
    return &schema.Resource{
        Create: resource{{ $.ResourceName -}}Create,
        Read: resource{{ $.ResourceName -}}Read,
{{- if or $.Updatable $.RootLabels }}
        Update: resource{{ $.ResourceName -}}Update,
{{- end}}
        Delete: resource{{ $.ResourceName -}}Delete,

{{-  if not $.ExcludeImport }}

        Importer: &schema.ResourceImporter{
            State: resource{{ $.ResourceName -}}Import,
        },
{{- end}}

        Timeouts: &schema.ResourceTimeout {
            Create: schema.DefaultTimeout({{ $.Timeouts.InsertMinutes -}} * time.Minute),
{{- if or $.Updatable $.RootLabels }}
            Update: schema.DefaultTimeout({{ $.Timeouts.UpdateMinutes -}} * time.Minute),
{{- end}}
            Delete: schema.DefaultTimeout({{ $.Timeouts.DeleteMinutes -}} * time.Minute),
        },
{{ if $.SchemaVersion }}
        SchemaVersion: {{ $.SchemaVersion -}},
{{- end}}
{{- if $.MigrateState }}
        MigrateState: {{ $.MigrateState -}},
{{- end}}
{{- if $.StateUpgraders }}

        StateUpgraders: []schema.StateUpgrader{
{{-       range $v := $.StateUpgradersCount }}
          {
            Type:    resource{{$.ResourceName}}ResourceV{{$v}}().CoreConfigSchema().ImpliedType(),
            Upgrade: Resource{{$.ResourceName}}UpgradeV{{$v}},
            Version: {{$v}},
          },
{{-       end }}
        },
{{- end }}
{{- if or (and (or $.HasProject $.HasRegion $.HasZone) (not $.ExcludeDefaultCdiff)) $.CustomDiff }}
        CustomizeDiff: customdiff.All(
{{-   if $.UnorderedListProperties }}
{{-     range $prop := $.UnorderedListProperties }}
        resource{{ $.ResourceName }}{{ camelize $prop.Name "upper" }}SetStyleDiff,
{{-     end}}
{{-   end}}
{{- if $.CustomDiff -}}
{{-          range $cdiff := $.CustomDiff }}
        {{ $cdiff }},
{{- end}}
{{- end}}
{{- if and ($.HasProject) (not $.ExcludeDefaultCdiff) }}
            tpgresource.DefaultProviderProject,
{{- end -}}
{{if and ($.HasRegion) (not $.ExcludeDefaultCdiff)  }}
            tpgresource.DefaultProviderRegion,
{{- end -}}
{{if and ($.HasZone) (not $.ExcludeDefaultCdiff)  }}
            tpgresource.DefaultProviderZone,
{{- end }}
        ),
{{- end}}
{{- if $.CustomCode.ValidateRawResourceConfigFuncs }}
		ValidateRawResourceConfigFuncs: []schema.ValidateRawResourceConfigFunc{
			{{$.CustomTemplate $.CustomCode.ValidateRawResourceConfigFuncs false}},
		},
{{- end }}
{{ if $.DeprecationMessage }}
        DeprecationMessage: "{{ $.DeprecationMessage -}}",
{{- end}}

        Schema: map[string]*schema.Schema{
			{{- range $prop := $.OrderProperties $.AllUserProperties }}
{{template "SchemaFields" $prop -}}
			{{- end }}
            {{- range $prop := $.VirtualFields }}
{{template "SchemaFields" $prop -}}
            {{- end }}
{{- if $.CustomCode.ExtraSchemaEntry }} 
    {{ $.CustomTemplate $.CustomCode.ExtraSchemaEntry false -}}
{{- end}}
{{ if $.HasProject -}}
            "project": {
                Type:     schema.TypeString,
                Optional: true,
                Computed: true,
                ForceNew: true,
            },
{{- end}}
{{- if $.HasSelfLink }}
            "self_link": {
                Type:     schema.TypeString,
                Computed: true,
            },
{{- end}}
        },
        UseJSONNumber: true,
    }
}

{{- range $prop := $.AllUserProperties }}
{{template "SchemaSubResource" $prop}}
{{- end}}

{{- range $prop := $.UnorderedListProperties }}
func resource{{ $.ResourceName }}{{ camelize $prop.Name "upper" }}SetStyleDiff(_ context.Context, diff *schema.ResourceDiff, meta interface{}) error {
{{template "UnorderedListCustomizeDiff" $prop}}
}
{{- end}}

func resource{{ $.ResourceName -}}Create(d *schema.ResourceData, meta interface{}) error {
{{- if and ($.GetAsync) (and ($.GetAsync.IsA "OpAsync") ($.GetAsync.IncludeProject) ($.GetAsync.Allow "Create")) -}}
    var project string
{{- end}}
    config := meta.(*transport_tpg.Config)
{{ if $.CustomCode.CustomCreate -}}
    {{ $.CustomTemplate $.CustomCode.CustomCreate false -}}
{{  else  -}}
    userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
    if err != nil {
        return err
    }

    obj := make(map[string]interface{})

{{- range $prop := $.SettableProperties }}
    {{ $prop.CamelizeProperty -}}Prop, err := expand{{ if $.NestedQuery -}}Nested{{ end }}{{ $.ResourceName -}}{{ camelize $prop.Name "upper" -}}({{ if $prop.FlattenObject }}nil{{ else }}d.Get("{{ underscore $prop.Name }}"){{ end }}, d, config)
    if err != nil {
        return err
    {{- if $prop.SendEmptyValue -}}
    } else if v, ok := d.GetOkExists("{{ underscore $prop.Name -}}"); ok || !reflect.DeepEqual(v, {{ $prop.CamelizeProperty -}}Prop) {
    {{-      else if $prop.FlattenObject -}}
    } else if !tpgresource.IsEmptyValue(reflect.ValueOf({{ $prop.CamelizeProperty -}}Prop)) {
    {{-      else -}}
    } else if v, ok := d.GetOkExists("{{ underscore $prop.Name -}}"); !tpgresource.IsEmptyValue(reflect.ValueOf({{ $prop.CamelizeProperty -}}Prop)) && (ok || !reflect.DeepEqual(v, {{ $prop.CamelizeProperty -}}Prop)) {
    {{- end}}
        obj["{{ $prop.ApiName -}}"] = {{ $prop.CamelizeProperty -}}Prop
    }
    {{- end}}

{{if $.CustomCode.Encoder -}}
    obj, err = resource{{ $.ResourceName -}}Encoder(d, meta, obj)
    if err != nil {
        return err
    }
{{- end}}

{{if $.Mutex -}}
    lockName, err := tpgresource.ReplaceVars(d, config, "{{ $.Mutex -}}")
    if err != nil {
        return err
    }
    transport_tpg.MutexStore.Lock(lockName)
    defer transport_tpg.MutexStore.Unlock(lockName)
{{- end}}

    url, err := tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{"{{"}}{{$.ProductMetadata.Name}}BasePath{{"}}"}}{{$.CreateUri}}")
    if err != nil {
        return err
    }

    log.Printf("[DEBUG] Creating new {{ $.Name -}}: %#v", obj)
{{- if $.NestedQuery -}}
{{- if $.NestedQuery.ModifyByPatch }}
{{/*# Keep this after mutex - patch request data relies on current resource state */}}
    obj, err = resource{{ $.ResourceName -}}PatchCreateEncoder(d, meta, obj)
    if err != nil {
        return err
    }
{{- if $.UpdateMask }}
    url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": "{{ join $.NestedQuery.Keys "." -}}"})
    if err != nil {
        return err
    }
{{- end}}
{{- end}}
{{- end}}
    billingProject := ""

{{if $.HasProject -}}
    project, err := tpgresource.GetProject(d, config)
    if err != nil {
        return fmt.Errorf("Error fetching project for {{ $.Name -}}: %s", err)
    }
{{if $.LegacyLongFormProject -}}
    billingProject = strings.TrimPrefix(project, "projects/")
{{      else -}}
    billingProject = project
{{- end}}
{{- end}}

{{if $.SupportsIndirectUserProjectOverride -}}
    if parts := regexp.MustCompile(`projects\/([^\/]+)\/`).FindStringSubmatch(url); parts != nil {
        billingProject = parts[1]
    }
{{- end}}

    // err == nil indicates that the billing_project value was found
    if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
      billingProject = bp
    }

    headers := make(http.Header)
{{- if $.CustomCode.PreCreate }}
    {{ $.CustomTemplate $.CustomCode.PreCreate false -}}
{{- end}}
    res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
        Config: config,
        Method: "{{ upper $.CreateVerb -}}",
        Project: billingProject,
        RawURL: url,
        UserAgent: userAgent,
        Body: obj,
        Timeout: d.Timeout(schema.TimeoutCreate),
        Headers: headers,
{{- if $.ErrorRetryPredicates }}
        ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorRetryPredicates "," -}}{{"}"}},
{{- end}}
{{- if $.ErrorAbortPredicates }}
        ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{ join $.ErrorAbortPredicates "," -}}{{"}"}},
{{- end}}
    })
    if err != nil {
{{- if and ($.CustomCode.PostCreateFailure) (not $.GetAsync) -}}
        resource{{ $.ResourceName -}}PostCreateFailure(d, meta)
{{- end}}
        return fmt.Errorf("Error creating {{ $.Name -}}: %s", err)
    }
{{- /* Set computed resource properties required for building the ID from create API response (as long as Create doesn't use an async operation) */}}
{{- /* This is necessary so that the ID is set correctly (and so that the following Read can succeed.) */}}
{{- /* Technically this should possibly use the read URL explicitly, since id_format could differ - but that might need to be in addition to id_format anyway. */}}
{{- if and $.HasPostCreateComputedFields (or (or (not $.GetAsync) (not ($.GetAsync.Allow "Create"))) (and $.GetAsync (and ($.GetAsync.IsA "PollAsync") ($.GetAsync.Allow "Create"))))}}
    // Set computed resource properties from create API response so that they're available on the subsequent Read
    // call.
    err = resource{{ $.ResourceName }}PostCreateSetComputedFields(d, meta, res)
    if err != nil {
        return fmt.Errorf("setting computed ID format fields: %w", err)
    }
{{- end}}

    // Store the ID now
    id, err := tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{ $.IdFormat -}}")
    if err != nil {
        return fmt.Errorf("Error constructing id: %s", err)
    }
    d.SetId(id)

{{if and $.GetAsync ($.GetAsync.Allow "Create") -}}
{{  if ($.GetAsync.IsA "OpAsync") -}}
{{    if and $.GetAsync.Result.ResourceInsideResponse $.HasPostCreateComputedFields -}}
    // Use the resource in the operation response to populate
    // identity fields and d.Id() before read
    var opRes map[string]interface{}
    err = {{ $.ClientNamePascal -}}OperationWaitTimeWithResponse(
    config, res, &opRes, {{if or $.HasProject $.GetAsync.IncludeProject -}} {{if $.LegacyLongFormProject -}}tpgresource.GetResourceNameFromSelfLink(project){{ else }}project{{ end }}, {{ end -}} "Creating {{ $.Name -}}", userAgent,
        d.Timeout(schema.TimeoutCreate))
    if err != nil {
{{if $.CustomCode.PostCreateFailure -}}
        resource{{ $.ResourceName -}}PostCreateFailure(d, meta)
{{- end}}
{{-          if not $.TaintResourceOnFailedCreate -}}
        // The resource didn't actually create
        d.SetId("")

{{           end -}}
        return fmt.Errorf("Error waiting to create {{ $.Name -}}: %s", err)
    }

{{if $.CustomCode.Decoder -}}
    opRes, err = resource{{ $.ResourceName -}}Decoder(d, meta, opRes)
    if err != nil {
        return fmt.Errorf("Error decoding response from operation: %s", err)
    }
    if opRes == nil {
        return fmt.Errorf("Error decoding response from operation, could not find object")
    }
{{- end}}

{{if $.NestedQuery -}}
{{if $.NestedQuery.Keys -}}
    if _, ok := opRes["{{ index $.NestedQuery.Keys 0 -}}"]; ok {
        opRes, err = flattenNested{{ $.ResourceName -}}(d, meta, opRes)
        if err != nil {
            return fmt.Errorf("Error getting nested object from operation response: %s", err)
        }
        if opRes == nil {
            // Object isn't there any more - remove it from the state.
            return fmt.Errorf("Error decoding response from operation, could not find nested object")
        }
    }
{{- end}}
{{- end}}
    {{- if $.HasPostCreateComputedFields}}
    {{- $renderedIdFromName := "false" }}
    {{- range $prop := $.GettableProperties }}
    {{- /* Check if prop is potentially computed */}}
    {{-   if and ($.InPostCreateComputed $prop) (and (or $prop.Output $prop.DefaultFromApi) (not $prop.IgnoreRead)) }}
    {{-     if and (eq $prop.CustomFlatten "templates/terraform/custom_flatten/id_from_name.tmpl") (eq $renderedIdFromName "false") }}
    // Setting `name` field so that `id_from_name` flattener will work properly.
    if err := d.Set("name", flatten{{ if $.NestedQuery -}}Nested{{end}}{{ $.ResourceName -}}Name(opRes["name"], d, config)); err != nil {
        return err
    }
    {{-       $renderedIdFromName = "true" }}
    {{-     end }}
    {{-     if and $prop.Output (not $prop.IgnoreRead) }}
    if err := d.Set("{{ underscore $prop.Name -}}", flatten{{ if $.NestedQuery -}}Nested{{end}}{{ $.ResourceName -}}{{ camelize $prop.Name "upper"  -}}(opRes["{{ $prop.ApiName -}}"], d, config)); err != nil {
        return err
    }
    {{-     else if and $prop.DefaultFromApi (not $prop.IgnoreRead) }}
    // {{ underscore $prop.Name }} is set by API when unset
    if tpgresource.IsEmptyValue(reflect.ValueOf(d.Get("{{ underscore $prop.Name }}"))) {
        if err := d.Set("{{ underscore $prop.Name -}}", flatten{{ if $.NestedQuery -}}Nested{{end}}{{ $.ResourceName -}}{{ camelize $prop.Name "upper"  -}}(opRes["{{ $prop.ApiName -}}"], d, config)); err != nil {
            return fmt.Errorf(`Error setting computed identity field "{{ underscore $prop.Name }}": %s`, err)
        }
    }
    {{-     end }}
    {{-   end }}{{/* prop is potentially computed */}}
    {{- end }}{{/* range */}}
    {{- end}}

    // This may have caused the ID to update - update it if so.
    id, err = tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{ $.IdFormat -}}")
    if err != nil {
        return fmt.Errorf("Error constructing id: %s", err)
    }
    d.SetId(id)

{{        else -}}
    err = {{ $.ClientNamePascal -}}OperationWaitTime(
    config, res, {{if or $.HasProject $.GetAsync.IncludeProject -}} {{if $.LegacyLongFormProject -}}tpgresource.GetResourceNameFromSelfLink(project){{ else }}project{{ end }}, {{ end -}} "Creating {{ $.Name -}}", userAgent,
        d.Timeout(schema.TimeoutCreate))

    if err != nil {
{{if $.CustomCode.PostCreateFailure -}}
        resource{{ $.ResourceName -}}PostCreateFailure(d, meta)
{{ end}}
{{-          if not $.TaintResourceOnFailedCreate -}}
        // The resource didn't actually create
        d.SetId("")
{{- end}}
        return fmt.Errorf("Error waiting to create {{ $.Name -}}: %s", err)
    }

{{        end  -}}
{{      end -}}{{/*if ($.GetAsync.IsA "OpAsync")*/}}
{{    end -}}{{/*if and $.GetAsync ($.GetAsync.Allow "Create")*/}}
{{if $.CustomCode.PostCreate -}} 
    {{- $.CustomTemplate $.CustomCode.PostCreate false -}}
{{- end}}

{{if and ($.GetAsync) ($.GetAsync.Allow "Create") -}}
{{if $.GetAsync.IsA "PollAsync" -}}
    err = transport_tpg.PollingWaitTime(resource{{ $.ResourceName -}}PollRead(d, meta), {{ $.GetAsync.CheckResponseFuncExistence -}}, "Creating {{ $.Name -}}", d.Timeout(schema.TimeoutCreate), {{ $.GetAsync.TargetOccurrences -}})
    if err != nil {
{{- if $.GetAsync.SuppressError -}}

        log.Printf("[ERROR] Unable to confirm eventually consistent {{ $.Name }} %q finished updating: %q", d.Id(), err)

{{-        else }}
{{- if $.CustomCode.PostCreateFailure -}}
        resource{{ $.ResourceName -}}PostCreateFailure(d, meta)
{{- end}}
        return fmt.Errorf("Error waiting to create {{ $.Name -}}: %s", err)
{{- end}}
    }
{{- end}}
{{- end}}

    log.Printf("[DEBUG] Finished creating {{ $.Name }} %q: %#v", d.Id(), res)

    return resource{{ $.ResourceName -}}Read(d, meta)
{{  end -}}
}

{{if and ($.GetAsync) ($.GetAsync.IsA "PollAsync")}}
func resource{{ $.ResourceName -}}PollRead(d *schema.ResourceData, meta interface{}) transport_tpg.PollReadFunc {
    return func() (map[string]interface{}, error) {
        config := meta.(*transport_tpg.Config)


        url, err := tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{"{{"}}{{$.ProductMetadata.Name}}BasePath{{"}}"}}{{$.SelfLinkUri}}")

        if err != nil {
            return nil, err
        }

        billingProject := ""

{{if $.HasProject -}}
        project, err := tpgresource.GetProject(d, config)
        if err != nil {
            return nil, fmt.Errorf("Error fetching project for {{ $.Name -}}: %s", err)
        }
{{if $.LegacyLongFormProject -}}
        billingProject = strings.TrimPrefix(project, "projects/")
{{        else -}}
        billingProject = project
{{- end}}
{{- end}}

{{if $.SupportsIndirectUserProjectOverride -}}
        if parts := regexp.MustCompile(`projects\/([^\/]+)\/`).FindStringSubmatch(url); parts != nil {
            billingProject = parts[1]
        }
{{- end}}

        // err == nil indicates that the billing_project value was found
        if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
        billingProject = bp
        }

        userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
        if err != nil {
            return nil, err
        }

        res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
            Config: config,
            Method: "{{ upper $.ReadVerb -}}",
            Project: billingProject,
            RawURL: url,
            UserAgent: userAgent,
{{if $.ErrorRetryPredicates -}}
            ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorRetryPredicates "," -}}{{"}"}},
{{- end}}
{{- if $.ErrorAbortPredicates }}
            ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorAbortPredicates "," -}}{{"}"}},
{{- end}}
        })
        if err != nil {
            return res, err
        }
{{- if $.CustomCode.Decoder }}
{{""}}
{{- end }}
{{- if $.NestedQuery }}
        res, err = flattenNested{{ $.ResourceName -}}(d, meta, res)
        if err != nil {
            return nil, err
        }

        if res == nil {
            return nil, tpgresource.Fake404("nested", "{{ $.ResourceName }}")
        }
{{- if not $.CustomCode.Decoder }}
{{""}}
{{- end }}
{{- end -}}
{{- if $.CustomCode.Decoder -}}
        res, err = resource{{ $.ResourceName -}}Decoder(d, meta, res)
        if err != nil {
            return nil, err
        }
        if res == nil {
            return nil, tpgresource.Fake404("decoded", "{{ $.ResourceName }}")
        }
{{ end }}
        return res, nil
    }
}
{{  end }}
func resource{{ $.ResourceName -}}Read(d *schema.ResourceData, meta interface{}) error {
{{if $.ExcludeRead -}}
  // This resource could not be read from the API.
  return nil
{{  else  -}}
    config := meta.(*transport_tpg.Config)
    userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
    if err != nil {
        return err
    }

    url, err := tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{"{{"}}{{$.ProductMetadata.Name}}BasePath{{"}}"}}{{$.SelfLinkUri}}{{$.ReadQueryParams}}")
    if err != nil {
        return err
    }

    billingProject := ""

{{if $.HasProject -}}
    project, err := tpgresource.GetProject(d, config)
    if err != nil {
        return fmt.Errorf("Error fetching project for {{ $.Name -}}: %s", err)
    }
{{if $.LegacyLongFormProject -}}
    billingProject = strings.TrimPrefix(project, "projects/")
{{    else -}}
    billingProject = project
{{- end}}
{{- end}}

{{if $.SupportsIndirectUserProjectOverride -}}
    if parts := regexp.MustCompile(`projects\/([^\/]+)\/`).FindStringSubmatch(url); parts != nil {
        billingProject = parts[1]
    }
{{- end}}

    // err == nil indicates that the billing_project value was found
    if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
      billingProject = bp
    }

    headers := make(http.Header)
    {{- if $.CustomCode.PreRead }}
        {{ $.CustomTemplate $.CustomCode.PreRead false -}}
    {{- end }}
    res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
        Config: config,
        Method: "{{ upper $.ReadVerb -}}",
        Project: billingProject,
        RawURL: url,
        UserAgent: userAgent,
        Headers: headers,
{{- if $.ErrorRetryPredicates }}
        ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorRetryPredicates "," -}}{{"}"}},
{{- end}}
{{- if $.ErrorAbortPredicates }}
        ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorAbortPredicates "," -}}{{"}"}},
{{- end}}
    })
    if err != nil {
{{- if $.ReadErrorTransform -}}
        return transport_tpg.HandleNotFoundError({{ $.ReadErrorTransform }}(err), d, fmt.Sprintf("{{ $.ResourceName }} %q", d.Id()))
{{-  else }}
        return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("{{ $.ResourceName }} %q", d.Id()))
{{- end}}
    }
{{- if $.CustomCode.PostRead }}
    {{ $.CustomTemplate $.CustomCode.PostRead false -}}
{{- end }}

{{if $.NestedQuery -}}
    res, err = flattenNested{{ $.ResourceName -}}(d, meta, res)
    if err != nil {
        return err
    }

    if res == nil {
        // Object isn't there any more - remove it from the state.
        log.Printf("[DEBUG] Removing {{ $.ResourceName }} because it couldn't be matched.")
        d.SetId("")
        return nil
    }

{{- end}}

{{if $.CustomCode.Decoder -}}
    res, err = resource{{ $.ResourceName -}}Decoder(d, meta, res)
    if err != nil {
        return err
    }

    if res == nil {
        // Decoding the object has resulted in it being gone. It may be marked deleted
        log.Printf("[DEBUG] Removing {{ $.ResourceName }} because it no longer exists.")
        d.SetId("")
        return nil
    }
{{ end}}
{{- if $.VirtualFields }}

  // Explicitly set virtual fields to default values if unset
{{- range $prop := $.VirtualFields }}
{{-      if not (eq $prop.DefaultValue nil) }}
    if _, ok := d.GetOkExists("{{ $prop.Name -}}"); !ok {
        if err := d.Set("{{ $prop.Name -}}", {{ $prop.GoLiteral $prop.DefaultValue -}}); err != nil {
            return fmt.Errorf("Error setting {{ $prop.Name -}}: %s", err)
        }
    }
{{- end}}
{{- end}}
{{- end}}
{{- if $.HasProject }}
    if err := d.Set("project", project); err != nil {
        return fmt.Errorf("Error reading {{ $.Name -}}: %s", err)
    }
{{- end}}

{{if $.HasRegion -}}
    region, err := tpgresource.GetRegion(d, config)
    if err != nil {
        return err
    }
    if err := d.Set("region", region); err != nil {
        return fmt.Errorf("Error reading {{ $.Name -}}: %s", err)
    }
{{- end}}

{{if $.HasZone -}}
    zone, err := tpgresource.GetZone(d, config)
    if err != nil {
        return err
    }
    if err := d.Set("zone", zone); err != nil {
        return fmt.Errorf("Error reading {{ $.Name -}}: %s", err)
    }
{{- end}}
{{ range $prop := $.ReadProperties }}
{{if $prop.FlattenObject -}}
// Terraform must set the top level schema field, but since this object contains collapsed properties
// it's difficult to know what the top level should be. Instead we just loop over the map returned from flatten.
    if flattenedProp := flatten{{ if $.NestedQuery -}}Nested{{end}}{{ $.ResourceName -}}{{ camelize $prop.Name "upper"  -}}(res["{{ $prop.ApiName -}}"], d, config); flattenedProp != nil {
        if gerr, ok := flattenedProp.(*googleapi.Error); ok {
            return fmt.Errorf("Error reading {{ $.Name -}}: %s", gerr)
        }
        casted := flattenedProp.([]interface{})[0]
        if casted != nil {
            for k, v := range casted.(map[string]interface{}) {
                if err := d.Set(k, v); err != nil {
                    return fmt.Errorf("Error setting %s: %s", k, err)
                }
            }
        }
    }
{{-    else -}}
    if err := d.Set("{{ underscore $prop.Name -}}", flatten{{ if $.NestedQuery -}}Nested{{end}}{{ $.ResourceName -}}{{ camelize $prop.Name "upper" -}}(res["{{ $prop.ApiName -}}"], d, config)); err != nil {
        return fmt.Errorf("Error reading {{ $.Name -}}: %s", err)
    }
{{- end}}
{{- end}}
{{if $.HasSelfLink -}}
    if err := d.Set("self_link", tpgresource.ConvertSelfLinkToV1(res["selfLink"].(string))); err != nil {
        return fmt.Errorf("Error reading {{ $.Name -}}: %s", err)
    }
{{- end}}

    return nil
{{  end -}}
}

{{if $.Updatable -}}
func resource{{ $.ResourceName -}}Update(d *schema.ResourceData, meta interface{}) error {
{{-     if and ($.GetAsync) (and ($.GetAsync.IsA "OpAsync") ($.GetAsync.IncludeProject) ($.GetAsync.Allow "update")) -}}
    var project string
{{-     end}}
    config := meta.(*transport_tpg.Config)
{{      if $.CustomCode.CustomUpdate -}}
    {{ $.CustomTemplate $.CustomCode.CustomUpdate false -}}
{{      else  -}}
    userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
    if err != nil {
        return err
    }

    billingProject := ""

{{          if $.HasProject -}}
    project, err := tpgresource.GetProject(d, config)
    if err != nil {
        return fmt.Errorf("Error fetching project for {{ $.Name -}}: %s", err)
    }
{{              if $.LegacyLongFormProject -}}
    billingProject = strings.TrimPrefix(project, "projects/")
{{              else -}}
    billingProject = project
{{-             end}}
{{-         end}}


{{          if not $.Immutable -}}
    obj := make(map[string]interface{})
{{-             range $prop := $.UpdateBodyProperties }}
    {{/* flattened $s won't have something stored in state so instead nil is passed to the next expander. */}}
    {{- $prop.CamelizeProperty -}}Prop, err := expand{{ if $.NestedQuery -}}Nested{{end}}{{ $.ResourceName -}}{{ camelize $prop.Name "upper"  -}}({{ if $prop.FlattenObject }}nil{{else}}d.Get("{{underscore $prop.Name}}"){{ end }}, d, config)
    if err != nil {
        return err
{{-                 if $prop.SendEmptyValue -}}
    } else if v, ok := d.GetOkExists("{{ underscore $prop.Name -}}"); ok || !reflect.DeepEqual(v, {{ $prop.CamelizeProperty -}}Prop) {
{{-                 else if $prop.FlattenObject -}}
    } else if !tpgresource.IsEmptyValue(reflect.ValueOf({{ $prop.CamelizeProperty -}}Prop)) {
{{-                 else -}}
    } else if v, ok := d.GetOkExists("{{ underscore $prop.Name -}}"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, {{ $prop.CamelizeProperty -}}Prop)) {
{{-                 end}}
        obj["{{ $prop.ApiName -}}"] = {{ $prop.CamelizeProperty -}}Prop
    }
{{-             end}}

{{/*     We need to decide what encoder to use here - if there's an update encoder, use that! -*/}}
{{              if $.CustomCode.UpdateEncoder -}}
    obj, err = resource{{ $.ResourceName -}}UpdateEncoder(d, meta, obj)
    if err != nil {
        return err
    }
{{              else if $.CustomCode.Encoder -}}
    obj, err = resource{{ $.ResourceName -}}Encoder(d, meta, obj)
    if err != nil {
        return err
    }
{{-             end}}

{{              if $.Mutex -}}
    lockName, err := tpgresource.ReplaceVars(d, config, "{{ $.Mutex -}}")
    if err != nil {
        return err
    }
    transport_tpg.MutexStore.Lock(lockName)
    defer transport_tpg.MutexStore.Unlock(lockName)
{{-             end}}

    url, err := tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{"{{"}}{{$.ProductMetadata.Name}}BasePath{{"}}"}}{{ $.UpdateUri }}")
    if err != nil {
        return err
    }

    log.Printf("[DEBUG] Updating {{ $.Name }} %q: %#v", d.Id(), obj)
	headers := make(http.Header)
{{-              if $.UpdateMask }}
{{ $.CustomTemplate "templates/terraform/update_mask.go.tmpl" false -}}
{{              end}}
{{-             if $.CustomCode.PreUpdate -}}{{""}}
    {{ $.CustomTemplate $.CustomCode.PreUpdate true -}}
{{              end}}
{{              if $.NestedQuery -}}
{{                  if $.NestedQuery.ModifyByPatch -}}
{{/*#       Keep this after mutex - patch request data relies on current resource state */}}
    obj, err = resource{{ $.ResourceName -}}PatchUpdateEncoder(d, meta, obj)
    if err != nil {
        return err
    }
{{-                 end}}
{{-             end}}
{{-              if $.SupportsIndirectUserProjectOverride -}}
    if parts := regexp.MustCompile(`projects\/([^\/]+)\/`).FindStringSubmatch(url); parts != nil {
        billingProject = parts[1]
    }
{{-             end}}

    // err == nil indicates that the billing_project value was found
    if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
      billingProject = bp
    }

{{              if $.UpdateMask -}}
// if updateMask is empty we are not updating anything so skip the post
if len(updateMask) > 0 {
{{-             end}}
    res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
        Config: config,
        Method: "{{ $.UpdateVerb -}}",
        Project: billingProject,
        RawURL: url,
        UserAgent: userAgent,
        Body: obj,
        Timeout: d.Timeout(schema.TimeoutUpdate),
		Headers:   headers,
{{-              if $.ErrorRetryPredicates }}
        ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorRetryPredicates "," -}}{{"}"}},
{{-             end}}
{{-             if $.ErrorAbortPredicates }}
        ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorAbortPredicates "," -}}{{"}"}},
{{-             end}}
    })

    if err != nil {
        return fmt.Errorf("Error updating {{ $.Name }} %q: %s", d.Id(), err)
    } else {
        log.Printf("[DEBUG] Finished updating {{ $.Name }} %q: %#v", d.Id(), res)
    }

{{              if and ($.GetAsync) ($.GetAsync.Allow "update") -}}
{{                  if $.GetAsync.IsA "OpAsync" -}}
    err = {{ $.ClientNamePascal -}}OperationWaitTime(
        config, res, {{if or $.HasProject $.GetAsync.IncludeProject -}} {{if $.LegacyLongFormProject -}}tpgresource.GetResourceNameFromSelfLink(project){{ else }}project{{ end }}, {{ end -}} "Updating {{ $.Name -}}", userAgent,
        d.Timeout(schema.TimeoutUpdate))

    if err != nil {
        return err
    }
{{-             if not $.FieldSpecificUpdateMethods }}
{{""}}
{{-             end}}
{{-                  else if $.GetAsync.IsA "PollAsync" -}}
    err = transport_tpg.PollingWaitTime(resource{{ $.ResourceName -}}PollRead(d, meta), {{ $.GetAsync.CheckResponseFuncExistence -}}, "Updating {{ $.Name -}}", d.Timeout(schema.TimeoutUpdate), {{ $.GetAsync.TargetOccurrences -}})
    if err != nil {
{{                      if $.GetAsync.SuppressError -}}
        log.Printf("[ERROR] Unable to confirm eventually consistent {{ $.Name -}} %q finished updating: %q", d.Id(), err)
{{                      else -}}
        return err
{{-                     end}}
    }
{{-                 end}}
{{-             end}}
{{-              if $.UpdateMask -}}
  }
{{-             end}}
{{-         end}}{{/*if not immutable*/}}
{{-          if $.FieldSpecificUpdateMethods }}
    d.Partial(true)
{{             $CustomUpdateProps := $.PropertiesByCustomUpdate $.RootProperties }}
{{             range $group := $.PropertiesByCustomUpdateGroups }}
if d.HasChange("{{ join ($.PropertyNamesToStrings (index $CustomUpdateProps $group)) "\") || d.HasChange(\""}}") {
        obj := make(map[string]interface{})
{{		            if $group.FingerprintName }}
        getUrl, err := tpgresource.ReplaceVars(d, config, "{{"{{"}}{{$.ProductMetadata.Name}}BasePath{{"}}"}}{{$.SelfLinkUri}}")
        if err != nil {
            return err
        }
{{		                if $.SupportsIndirectUserProjectOverride -}}
        if parts := regexp.MustCompile(`projects\/([^\/]+)\/`).FindStringSubmatch(url); parts != nil {
            billingProject = parts[1]
        }
{{-                     end}}

        // err == nil indicates that the billing_project value was found
        if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
        billingProject = bp
        }

        getRes, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
            Config: config,
            Method: "{{ upper $.ReadVerb -}}",
            Project: billingProject,
            RawURL: getUrl,
            UserAgent: userAgent,
{{		                if $.ErrorRetryPredicates -}}
        	ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorRetryPredicates "," -}}{{"}"}},
{{-                     end}}
{{		                if $.ErrorAbortPredicates -}}
        	ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorRetryPredicates "," -}}{{"}"}},
{{-                     end}}
        })
        if err != nil {
            return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("{{ $.ResourceName }} %q", d.Id()))
        }

        obj["{{ $group.FingerprintName }}"] = getRes["{{ $group.FingerprintName }}"]

{{                  end  }}{{/*if FingerprintName*/}}
{{                  range $propsByKey := $.CustomUpdatePropertiesByKey $.AllUserProperties $group.UpdateUrl $group.UpdateId $group.FingerprintName $group.UpdateVerb }}
        {{ $propsByKey.ApiName -}}Prop, err := expand{{ if $.NestedQuery -}}Nested{{ end }}{{ $.ResourceName -}}{{ camelize $propsByKey.Name "upper"  -}}({{ if $propsByKey.FlattenObject }}nil{{else}}d.Get("{{underscore $propsByKey.Name}}"){{ end }}, d, config)
        if err != nil {
            return err
{{/*         There is some nuance in when we choose to send a value to an update function.
            This is unfortunate, but it's because of the way that GCP works, so there's
            no easy way out.  Some APIs require you to send `enable_foo: false`, while
            others will crash if you send `attribute: ''`.  We require this nuance to
            be annotated in ResourceName.yaml, since it is not discoverable automatically.

            The behavior here, which we believe to be correct, is to send a value if
            * It is non-empty OR
            * It is marked send_empty_value in ResourceName.yaml.
            AND
            * It has been set by the user OR
            * It has been modified by the expander in any way

            This subsumes both `ForceSendFields` and `NullFields` in the go API client -
            `NullFields` is a special case of `send_empty_value` where the empty value
            in question is go's literal nil.
-*/}}
{{-                      if $propsByKey.SendEmptyValue -}}
        } else if v, ok := d.GetOkExists("{{ underscore $propsByKey.Name -}}"); ok || !reflect.DeepEqual(v, {{ $propsByKey.ApiName -}}Prop) {
{{-                      else if $propsByKey.FlattenObject -}}
        } else if !tpgresource.IsEmptyValue(reflect.ValueOf({{ $propsByKey.ApiName -}}Prop)) {
{{-                      else -}}
        } else if v, ok := d.GetOkExists("{{ underscore $propsByKey.Name -}}"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, {{ $propsByKey.ApiName -}}Prop)) {
{{-                     end}}
            obj["{{ $propsByKey.ApiName -}}"] = {{ $propsByKey.ApiName -}}Prop
        }
{{-                  end -}}{{/*range propsByKey*/}}
{{/*     We need to decide what encoder to use here - if there's an update encoder, use that! -*/}}
{{                  if $.CustomCode.UpdateEncoder -}}
    obj, err = resource{{ $.ResourceName -}}UpdateEncoder(d, meta, obj)
    if err != nil {
        return err
    }
{{-                 end}}

{{                  if $.Mutex -}}
        lockName, err := tpgresource.ReplaceVars(d, config, "{{ $.Mutex -}}")
        if err != nil {
            return err
        }
        transport_tpg.MutexStore.Lock(lockName)
        defer transport_tpg.MutexStore.Unlock(lockName)
{{-                 end}}
        url, err := tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{"{{"}}{{$.ProductMetadata.Name}}BasePath{{"}}"}}{{ $group.UpdateUrl }}")
        if err != nil {
            return err
        }


        headers := make(http.Header)
{{                  if $.CustomCode.PreUpdate -}}
    {{ $.CustomTemplate $.CustomCode.PreUpdate false -}}
{{                  end}}
{{                  if $.SupportsIndirectUserProjectOverride -}}
        if parts := regexp.MustCompile(`projects\/([^\/]+)\/`).FindStringSubmatch(url); parts != nil {
            billingProject = parts[1]
        }
{{-                 end}}

        // err == nil indicates that the billing_project value was found
        if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
        billingProject = bp
        }

        res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
            Config: config,
            Method: "{{ $group.UpdateVerb }}",
            Project: billingProject,
            RawURL: url,
            UserAgent: userAgent,
            Body: obj,
            Timeout: d.Timeout(schema.TimeoutUpdate),
{{-                  if $.ErrorRetryPredicates -}}
        	ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorRetryPredicates "," -}}{{"}"}},
{{-                 end}}
{{-                 if $.ErrorAbortPredicates -}}
        	ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{  join $.ErrorAbortPredicates "," -}}{{"}"}},
{{-                 end}}
			Headers:   headers,
        })
        if err != nil {
            return fmt.Errorf("Error updating {{ $.Name }} %q: %s", d.Id(), err)
        } else {
        log.Printf("[DEBUG] Finished updating {{ $.Name }} %q: %#v", d.Id(), res)
    }

{{                  if and ($.GetAsync) ($.GetAsync.Allow "update") -}}
{{                      if $.GetAsync.IsA "OpAsync" -}}
	    err = {{ $.ClientNamePascal -}}OperationWaitTime(
	        config, res, {{if or $.HasProject $.GetAsync.IncludeProject -}} {{if $.LegacyLongFormProject -}}tpgresource.GetResourceNameFromSelfLink(project){{ else }}project{{ end }}, {{ end -}} "Updating {{ $.Name -}}", userAgent,
	        d.Timeout(schema.TimeoutUpdate))
	    if err != nil {
	        return err
	    }
{{-                      else if $.GetAsync.IsA "PollAsync" -}}
	    err = transport_tpg.PollingWaitTime(resource{{ $.ResourceName -}}PollRead(d, meta), {{ $.GetAsync.CheckResponseFuncExistence -}}, "Updating {{ $.Name -}}", d.Timeout(schema.TimeoutUpdate), {{ $.GetAsync.TargetOccurrences -}})
	    if err != nil {
{{-                          if $.GetAsync.SuppressError -}}
	        log.Printf("[ERROR] Unable to confirm eventually consistent {{ $.Name -}} %q finished updating: %q", d.Id(), err)
{{-                          else -}}
	        return err
{{-                         end}}
        }
{{-                     end}}
{{-                 end}}
    } 
{{-             end  }}{{/*range PropertiesByCustomUpdate*/}}
{{ "" }}
  d.Partial(false)
{{-         end  }}{{/*if FieldSpecificUpdateMethods*/}}

{{          if $.CustomCode.PostUpdate -}}
    {{ $.CustomTemplate $.CustomCode.PostUpdate false -}}
 {{end}}
    return resource{{ $.ResourceName -}}Read(d, meta)
{{-      end }}{{/*if CustomUpdate*/}}
}
{{  else if $.RootLabels -}}{{/*if not immutable*/}}
func resource{{ $.ResourceName -}}Update(d *schema.ResourceData, meta interface{}) error {
    // Only the root field "labels" and "terraform_labels" are mutable
    return resource{{ $.ResourceName -}}Read(d, meta)
}

{{ end}}
func resource{{ $.ResourceName }}Delete(d *schema.ResourceData, meta interface{}) error {
{{- if and ($.GetAsync) (and (and ($.GetAsync.IsA "OpAsync") $.GetAsync.IncludeProject) ($.GetAsync.Allow "delete")) }}
    var project string
{{- end }}
{{- if $.ExcludeDelete }}
    log.Printf("[WARNING] {{ $.ProductMetadata.Name }}{{" "}}{{ $.Name }} resources" +
    " cannot be deleted from Google Cloud. The resource %s will be removed from Terraform" +
    " state, but will still be present on Google Cloud.", d.Id())
    d.SetId("")

    return nil
{{- else }}
    config := meta.(*transport_tpg.Config)
    userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
    if err != nil {
        return err
    }
{{ if $.CustomCode.CustomDelete }} 
{{ $.CustomTemplate $.CustomCode.CustomDelete false -}}
{{- else }}

    billingProject := ""
    {{ if $.HasProject }}
    project, err := tpgresource.GetProject(d, config)
    if err != nil {
        return fmt.Errorf("Error fetching project for {{ $.Name }}: %s", err)
    }
        {{- if $.LegacyLongFormProject }}
    billingProject = strings.TrimPrefix(project, "projects/")
        {{- else }}
    billingProject = project
        {{- end }}
    {{- end }}
    {{- if $.Mutex }}

    lockName, err := tpgresource.ReplaceVars(d, config, "{{ $.Mutex }}")
    if err != nil {
        return err
    }
    transport_tpg.MutexStore.Lock(lockName)
    defer transport_tpg.MutexStore.Unlock(lockName)
    {{- end }}

    url, err := tpgresource.ReplaceVars{{if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{"{{"}}{{$.ProductMetadata.Name}}BasePath{{"}}"}}{{$.DeleteUri}}")
    if err != nil {
        return err
    }
    {{/*If the deletion of the object requires sending a request body, the custom code will set 'obj' */}}
    var obj map[string]interface{}
    {{- if and $.NestedQuery $.NestedQuery.ModifyByPatch }}
        {{/*Keep this after mutex - patch request data relies on current resource state*/}}
    obj, err = resource{{ $.ResourceName }}PatchDeleteEncoder(d, meta, obj)
    if err != nil {
        return transport_tpg.HandleNotFoundError(err, d, "{{ $.Name }}")
    }
        {{- if $.UpdateMask }}
    url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": "{{- join $.NestedQuery.Keys "." -}}"})
    if err != nil {
        return err
    }
        {{- end }}
    {{- end }}
    {{- if $.SupportsIndirectUserProjectOverride }}
    if parts := regexp.MustCompile(`projects\/([^\/]+)\/`).FindStringSubmatch(url); parts != nil {
        billingProject = parts[1]
    }
    {{- end }}

    // err == nil indicates that the billing_project value was found
    if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
      billingProject = bp
    }

    headers := make(http.Header)
    {{- if $.CustomCode.PreDelete }} 
        {{ $.CustomTemplate $.CustomCode.PreDelete false -}}
    {{- end }}

    log.Printf("[DEBUG] Deleting {{ $.Name }} %q", d.Id())
    res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
        Config: config,
        Method: "{{ camelize $.DeleteVerb "upper" -}}",
        Project: billingProject,
        RawURL: url,
        UserAgent: userAgent,
        Body: obj,
        Timeout: d.Timeout(schema.TimeoutDelete),
        Headers: headers,
        {{- if $.ErrorRetryPredicates }}
        ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{- join $.ErrorRetryPredicates "," -}}{{"}"}},
        {{- end }}
        {{- if $.ErrorAbortPredicates }}
        ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{{"{"}}{{- join $.ErrorAbortPredicates "," -}}{{"}"}},
        {{- end }}
    })
    if err != nil {
        return transport_tpg.HandleNotFoundError(err, d, "{{ $.Name }}")
    }
    {{ if and $.GetAsync ($.GetAsync.Allow "Delete") -}}
        {{ if $.GetAsync.IsA "PollAsync" }}
    err = transport_tpg.PollingWaitTime(resource{{ $.ResourceName }}PollRead(d, meta), {{ $.GetAsync.CheckResponseFuncAbsence }}, "Deleting {{ $.Name }}", d.Timeout(schema.TimeoutCreate), {{ $.Async.TargetOccurrences }})
    if err != nil {
            {{- if $.Async.SuppressError }}
        log.Printf("[ERROR] Unable to confirm eventually consistent {{ $.Name }} %q finished updating: %q", d.Id(), err)
            {{- else }}
        return fmt.Errorf("Error waiting to delete {{ $.Name }}: %s", err)
            {{- end }}
    }
        {{- else }}
    err = {{ $.ClientNamePascal }}OperationWaitTime(
        config, res, {{if or $.HasProject $.GetAsync.IncludeProject -}} {{if $.LegacyLongFormProject -}}tpgresource.GetResourceNameFromSelfLink(project){{ else }}project{{ end }}, {{ end -}} "Deleting {{ $.Name -}}", userAgent,
        d.Timeout(schema.TimeoutDelete))

    if err != nil {
        return err
    }
    {{- end }}
{{- end }}
{{- if $.CustomCode.PostDelete }}
    {{ $.CustomTemplate $.CustomCode.PostDelete false -}}
{{- end }}

    log.Printf("[DEBUG] Finished deleting {{ $.Name }} %q: %#v", d.Id(), res)
    return nil
{{- end }}{{/* custom code */}}
{{- end }}{{/* pre delete */}}
}

{{ if not $.ExcludeImport -}}
func resource{{ $.ResourceName }}Import(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
    {{- if $.CustomCode.CustomImport }}
        {{ $.CustomTemplate $.CustomCode.CustomImport false -}}
    {{- else }}
    config := meta.(*transport_tpg.Config)
    if err := tpgresource.ParseImportId([]string{
        {{- range $id := $.ImportIdFormatsFromResource }}
        "^{{ format2regex $id }}$",
        {{- end }}
    }, d, config); err != nil {
      return nil, err
    }

    // Replace import id for the resource id
    id, err := tpgresource.ReplaceVars{{ if $.LegacyLongFormProject -}}ForId{{ end -}}(d, config, "{{ $.IdFormat }}")
    if err != nil {
        return nil, fmt.Errorf("Error constructing id: %s", err)
    }
    d.SetId(id)
        {{ if $.VirtualFields }}

    // Explicitly set virtual fields to default values on import
            {{- range $vf := $.VirtualFields }}
                {{- if not (eq $vf.DefaultValue nil) }}
    if err := d.Set("{{ $vf.Name }}", {{ $vf.GoLiteral $vf.DefaultValue }}); err != nil {
        return nil, fmt.Errorf("Error setting {{ $vf.Name }}: %s", err)
    }
                {{- end }}
            {{- end }}
        {{- end }}
        {{- if $.CustomCode.PostImport }}
            {{ $.CustomTemplate $.CustomCode.PostImport false -}}
        {{- end }}

    return []*schema.ResourceData{d}, nil
    {{- end }}
}
{{ end }}
{{- range $prop := $.GettableProperties }}
    {{- if not $prop.IgnoreRead }}
        {{ template "flattenPropertyMethod" $prop -}}
    {{- end }}
{{- end }}
{{- range $prop := $.SettableProperties }}
    {{- template "expandPropertyMethod" $prop -}}
{{- end }}
{{- if $.CustomCode.Encoder }}
func resource{{ $.ResourceName -}}Encoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
{{ $.CustomTemplate $.CustomCode.Encoder false -}}
}
{{ end -}}
{{- if $.CustomCode.UpdateEncoder }}

func resource{{ $.ResourceName -}}UpdateEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
    {{ $.CustomTemplate $.CustomCode.UpdateEncoder false -}}
}
{{- end }}
{{- if $.NestedQuery }}
    {{ template "NestedQuery" $ }}
{{- end }}
{{- if $.CustomCode.Decoder }}
{{- if and $.CustomCode.UpdateEncoder (not $.NestedQuery ) }}
{{ "" }}
{{- end }}
func resource{{ $.ResourceName -}}Decoder(d *schema.ResourceData, meta interface{}, res map[string]interface{}) (map[string]interface{}, error) {
    {{ $.CustomTemplate $.CustomCode.Decoder false -}}
}
{{- end }}
{{- if $.CustomCode.PostCreateFailure }}
func resource{{ $.ResourceName -}}PostCreateFailure(d *schema.ResourceData, meta interface{}) {
    {{- $.CustomTemplate $.CustomCode.PostCreateFailure false -}}
}
{{- end }}
{{- if and $.SchemaVersion $.StateUpgraders }}

    {{ $.CustomTemplate $.StateMigrationFile false -}}
{{- end }}
{{- if and $.HasPostCreateComputedFields (or (or (not $.GetAsync) (not ($.GetAsync.Allow "Create"))) (and $.GetAsync (and ($.GetAsync.IsA "PollAsync") ($.GetAsync.Allow "Create"))))}}
func resource{{ $.ResourceName -}}PostCreateSetComputedFields(d *schema.ResourceData, meta interface{}, res map[string]interface{}) error {
    config := meta.(*transport_tpg.Config)
    {{- /* Don't render decoder for PollAsync resources - their decoders are expected to return `nil` until the resource completion completes, but we need to set their computed fields in order to call PollRead - so there can never be a dependency on the decoder. */}}
    {{- if and $.CustomCode.Decoder (or (not $.GetAsync) (not ($.GetAsync.IsA "PollAsync"))) }}
    res, err := resource{{ $.ResourceName -}}Decoder(d, meta, res)
    if err != nil {
        return fmt.Errorf("decoding response: %w", err)
    }
    if res == nil {
        return fmt.Errorf("decoding response, could not find object")
    }
    {{- end }}
    {{- if $.NestedQuery}}
    {{- if $.NestedQuery.Keys}}
    if _, ok := res["{{ index $.NestedQuery.Keys 0 -}}"]; ok {
        res, err := flattenNested{{ $.ResourceName -}}(d, meta, res)
        if err != nil {
            return fmt.Errorf("Error getting nested object from operation response: %s", err)
        }
        if res == nil {
            // Object isn't there any more - remove it from the state.
            return fmt.Errorf("Error decoding response from operation, could not find nested object")
        }
    }
    {{- end}}
    {{- end}}
    {{- $renderedIdFromName := "false" }}
    {{- range $prop := $.GettableProperties }}
    {{- /* Check if prop is potentially computed */}}
    {{-   if and ($.InPostCreateComputed $prop) (and (or $prop.Output $prop.DefaultFromApi) (not $prop.IgnoreRead)) }}
    {{-     if and (eq $prop.CustomFlatten "templates/terraform/custom_flatten/id_from_name.tmpl") (eq $renderedIdFromName "false") }}
    // Setting `name` field so that `id_from_name` flattener will work properly.
    if err := d.Set("name", flatten{{ if $.NestedQuery -}}Nested{{end}}{{ $.ResourceName -}}Name(res["name"], d, config)); err != nil {
        return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
    }
    {{-       $renderedIdFromName = "true" }}
    {{-     end }}
    {{-     if and $prop.Output (not $prop.IgnoreRead) }}
    if err := d.Set("{{ underscore $prop.Name -}}", flatten{{ if $.NestedQuery -}}Nested{{end}}{{ $.ResourceName -}}{{ camelize $prop.Name "upper"  -}}(res["{{ $prop.ApiName -}}"], d, config)); err != nil {
        return fmt.Errorf(`Error setting computed identity field "{{ underscore $prop.Name }}": %s`, err)
    }
    {{-     else if and $prop.DefaultFromApi (not $prop.IgnoreRead) }}
    // {{ underscore $prop.Name }} is set by API when unset
    if tpgresource.IsEmptyValue(reflect.ValueOf(d.Get("{{ underscore $prop.Name }}"))) {
        if err := d.Set("{{ underscore $prop.Name -}}", flatten{{ if $.NestedQuery -}}Nested{{end}}{{ $.ResourceName -}}{{ camelize $prop.Name "upper"  -}}(res["{{ $prop.ApiName -}}"], d, config)); err != nil {
            return fmt.Errorf(`Error setting computed identity field "{{ underscore $prop.Name }}": %s`, err)
        }
    }
    {{-     end }}
    {{-   end }}{{/* prop is potentially computed */}}
    {{- end }}{{/* range */}}
    return nil
}
{{- end }}
