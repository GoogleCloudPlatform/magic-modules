// Whether the IP CIDR change shrinks the block.
func IsShrinkageIpCidr(_ context.Context, old, new, _ interface{}) bool {
	_, oldCidr, oldErr := net.ParseCIDR(old.(string))
	_, newCidr, newErr := net.ParseCIDR(new.(string))

	if oldErr != nil || newErr != nil {
		// This should never happen. The ValidateFunc on the field ensures it.
		return false
	}

	oldStart, oldEnd := cidr.AddressRange(oldCidr)

	if newCidr.Contains(oldStart) && newCidr.Contains(oldEnd) {
		// This is a CIDR range expansion, no need to ForceNew, we have an update method for it.
		return false
	}

	return true
}

func sendSecondaryIpRangeIfEmptyDiff(_ context.Context, diff *schema.ResourceDiff, meta interface{}) error {
	// on create, return immediately as we don't need to determine if the value is empty or not
	if diff.Id() == "" {
		return nil
	}

	sendZero := diff.Get("send_secondary_ip_range_if_empty").(bool)
	if !sendZero {
		return nil
	}

	configSecondaryIpRange := diff.GetRawConfig().GetAttr("secondary_ip_range")
	if !configSecondaryIpRange.IsKnown() {
		return nil
	}
	configValueIsEmpty := configSecondaryIpRange.IsNull() || configSecondaryIpRange.LengthInt() == 0

	stateSecondaryIpRange := diff.GetRawState().GetAttr("secondary_ip_range")
	if !stateSecondaryIpRange.IsKnown() {
		return nil
	}
	stateValueIsEmpty := stateSecondaryIpRange.IsNull() || stateSecondaryIpRange.LengthInt() == 0

	if configValueIsEmpty && !stateValueIsEmpty {
		log.Printf("[DEBUG] setting secondary_ip_range to newly empty")
		diff.SetNew("secondary_ip_range", make([]interface{}, 0))
	}

	return nil
}

// DiffSuppressFunc for `log_config`.
func subnetworkLogConfigDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// If enable_flow_logs is enabled and log_config is not set, ignore the diff
	if enable_flow_logs := d.Get("enable_flow_logs"); enable_flow_logs.(bool) {
		logConfig := d.GetRawConfig().GetAttr("log_config")
		logConfigIsEmpty := logConfig.IsNull() || logConfig.LengthInt() == 0
		return logConfigIsEmpty
	}

	return false
}

// Helper function to create a unique string key for a secondary IP range map
func secondaryIpRangeKey(item map[string]interface{}) string {
	// Use range_name as the primary key, as it's required and unique per subnetwork.
	// Include ip_cidr_range as well for completeness, though range_name should suffice.
	name, _ := item["range_name"].(string)
	cidr, _ := item["ip_cidr_range"].(string)
	return fmt.Sprintf("%s:%s", name, cidr)
}

// Helper function to convert set item interface{} to map[string]interface{}
func itemToMap(item interface{}) (map[string]interface{}, bool) {
	m, ok := item.(map[string]interface{})
	if !ok {
		log.Printf("[WARN] Could not convert secondary_ip_range item to map[string]interface{}: %T", item)
	}
	return m, ok
}

// DiffSuppressFunc for `secondary_ip_range`.
func suppressUnmanagedSecondaryIpRangesDiff(_ context.Context, diff *schema.ResourceDiff, v interface{}) error {
	// Check if secondary_ip_range is part of the diff
	if !diff.HasChange("secondary_ip_range") {
		return nil
	}

	oldRaw, newRaw := diff.GetChange("secondary_ip_range")

	// Get the set of ranges from the prior state
	oldSet, ok := oldRaw.(*schema.Set)
	if !ok {
		// If prior state wasn't a set (e.g., first run), don't suppress
		return nil
	}
	priorStateRanges := map[string]interface{}{}
	for _, item := range oldSet.List() {
		if itemMap, ok := itemToMap(item); ok {
			key := secondaryIpRangeKey(itemMap)
			priorStateRanges[key] = item
		}
	}

	// Get the set of ranges from the config (new desired state)
	newSet, ok := newRaw.(*schema.Set)
	if !ok {
		// Should not happen if HasChange is true, but handle defensively
		return nil
	}
	configRanges := map[string]interface{}{}
	for _, item := range newSet.List() {
		if itemMap, ok := itemToMap(item); ok {
			key := secondaryIpRangeKey(itemMap)
			configRanges[key] = item // Store original item
		}
	}

	// Get the set of ranges read from the API (during refresh, stored in the diff's "old" value)
	// Note: diff.Get() returns the state *after* refresh, which might include unmanaged ranges.
	refreshedStateRangesRaw := diff.Get("secondary_ip_range")
	refreshedSet, ok := refreshedStateRangesRaw.(*schema.Set)
	if !ok {
		// If refreshed state isn't a set, something is wrong, don't suppress
		return nil
	}
	refreshedStateRanges := map[string]interface{}{}
	for _, item := range refreshedSet.List() {
		if itemMap, ok := itemToMap(item); ok {
			key := secondaryIpRangeKey(itemMap)
			refreshedStateRanges[key] = item // Store original item
		}
	}

	// Check if the only change is the removal of ranges not previously managed by Terraform
	onlyRemovingUnmanaged := true
	for key, _ := range refreshedStateRanges {
		_, inConfig := configRanges[key]
		_, inPriorState := priorStateRanges[key]
		
		// If a range exists in the refreshed state AND was in the prior state, BUT is NOT in the current config...
		if !inConfig && inPriorState {
			// A range managed by TF is being removed by the config - DO NOT suppress
			onlyRemovingUnmanaged = false
			break
		}

		
		if inConfig && !inPriorState {
			// A range is being added by the config - DO NOT suppress (let the add happen)
			// This also covers modifications, as a modified range appears as !inPriorState with the new key.
			// Or a range is being modified (handled by hash changes) - DO NOT suppress
			onlyRemovingUnmanaged = false
			break
		}
		// Cases covered:
		// - !inConfig && !inPriorState: Unmanaged range exists in API, ignore.
		// - inConfig && inPriorState: Managed range exists and is still in config, ignore.
	}

	if onlyRemovingUnmanaged && len(refreshedStateRanges) > len(configRanges) {
		// Suppress the diff for secondary_ip_range if the only difference is
		// the presence of unmanaged ranges in the refreshed state.
		// Set the planned "new" state to match the "refreshed" state read from the API.
		log.Printf("[DEBUG] Suppressing diff for unmanaged secondary_ip_range items. Setting planned state to refreshed state.")
		diff.SetNew("secondary_ip_range", refreshedStateRangesRaw) // Use SetNew instead of plan modifier
	}

	return nil
}
