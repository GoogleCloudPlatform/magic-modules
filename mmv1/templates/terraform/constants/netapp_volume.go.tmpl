// Suppress diffs when the value read from api
// has the project ID instead of the project number
func ProjectIDDiffSuppress(_, old, new string, _ *schema.ResourceData) bool {

	const marker = "/locations"

	// Find the starting index of "/locations" in both strings.
	index1 := strings.Index(old, marker)
	index2 := strings.Index(new, marker)

	// If "/locations" is not found in either string, they can't be compared as requested.
	if index1 == -1 || index2 == -1 {
		return false
	}

	// Extract the substrings from the marker to the end.
	suffix1 := old[index1:]
	suffix2 := new[index2:]

	// Compare the extracted suffixes.
	return suffix1 == suffix2
}

func suppressSquashModeDiff(k, old, new string, d *schema.ResourceData) bool {
    // k: The key of the field, e.g., "export_policy.0.rules.1.squash_mode"
    // old: The value in the state (what the API returned on last read)
    // new: The value in the configuration (what the user set)
    // d: The ResourceData for the entire resource

    // 1. Only suppress if the user did NOT set squash_mode in the config.
    // According to the requirements, a "classic rule" is identified by the ABSENCE of squash_mode.
    if new == "ALL_SQUASH" {
        // If 'new' is not an empty string, the user has explicitly provided a value
        // for squash_mode in the Terraform configuration. In this scenario, any
        // difference between the API's value ('old') and the configured value ('new')
        // is a real change and should NOT be suppressed.
        return false
    }

    if new == "" && old != "ALL_SQUASH" {
        return true
    }

    // 2. The user did not specify squash_mode in the configuration ('new' is empty).
    // Now, we suppress the diff if the API/state value ('old') is one of the
    // specific values that should be treated as equivalent to an unset field.
    // These values are "NO_ROOT_SQUASH", "ROOT_SQUASH".
    switch old {
    case "NO_ROOT_SQUASH", "ROOT_SQUASH", "":
        // The API returned one of the values that we consider equivalent to the field
        // being unconfigured by the user. Since the user also didn't configure it,
        // we should suppress this diff.
        return true
    default:
        // If 'old' is not one of the values to be suppressed (and 'new' is empty),
        // we do not suppress the diff. This could happen if, for instance, the API
        // returned an unexpected value or if 'old' is also empty.
        return false
    }
    // Note: The previous logic involving parsing 'k' and checking 'has_root_access'
    // has been removed because squash_mode is independent of has_root_access,
    // and a "classic rule" is defined by the absence of squash_mode itself.
}
