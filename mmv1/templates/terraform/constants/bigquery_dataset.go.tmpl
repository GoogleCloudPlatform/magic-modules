const datasetIdRegexp = `^[0-9A-Za-z_]+$`

var bigqueryDatasetAccessPrimitiveToRoleMap = map[string]string{
	"OWNER":  "roles/bigquery.dataOwner",
	"WRITER": "roles/bigquery.dataEditor",
	"READER": "roles/bigquery.dataViewer",
}

func validateDatasetId(v interface{}, k string) (ws []string, errors []error) {
    value := v.(string)
    if !regexp.MustCompile(datasetIdRegexp).MatchString(value) {
       errors = append(errors, fmt.Errorf(
            "%q must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_)", k))
    }

    if len(value) > 1024 {
        errors = append(errors, fmt.Errorf(
            "%q cannot be greater than 1,024 characters", k))
    }

    return
}

func validateDefaultTableExpirationMs(v interface{}, k string) (ws []string, errors []error) {
    value := v.(int)
    if value < 3600000 {
        errors = append(errors, fmt.Errorf("%q cannot be shorter than 3600000 milliseconds (one hour)", k))
    }

    return
}

{{- if ne $.Compiler "terraformgoogleconversion-codegen" }}
// bigqueryDatasetAccessHash is a custom hash function for the access block.
// It normalizes the 'role' field before hashing, treating legacy roles
// and their modern IAM equivalents as the same.
func resourceBigqueryDatasetAccessHash(v interface{}) int {
	m, ok := v.(map[string]interface{})
	if !ok {
		return 0
	}
	// Make a copy of the map to avoid modifying the underlying data.
	copy := make(map[string]interface{}, len(m))
	for k, val := range m {
		copy[k] = val
	}

	// Normalize the role if it exists and matches a legacy role.
	if role, ok := copy["role"].(string); ok {
		if newRole, ok := bigqueryDatasetAccessPrimitiveToRoleMap[role]; ok {
			copy["role"] = newRole
		}
	}

	// Use the default HashResource function on the (potentially modified) copy.
	return schema.HashResource(bigqueryDatasetAccessSchema())(copy)
}
{{- end }}
