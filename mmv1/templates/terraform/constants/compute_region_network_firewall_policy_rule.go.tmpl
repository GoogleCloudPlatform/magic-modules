//It adjusts obj in case network scope/context fields are used - in beta API both network scope/context fields are available.
//The GET method returns both of them with the same value (you can think of network scope field as an alias for the network context field).
// Terraform allows only one of them to be used (using 'conflicts' annotation) but because the terraform state has both of them we have
// to remove one of them if there's a change so that it's obvious what is the new value and to prevent terraform to report differences
// after the changes are applied.
//
// About declaring/using inner functions - this function is copied and used by org/global and regional firewall policy rules. However,
// using the same 'constants' shared code between resources is not allowed (when compiling I get that the function is already defined).
// Hence, there's an exact copy of this function for org/global and regional firewall policy rules.
// Inner function are created just to avoid code duplication but if defined as regular functions I would get 'function is already defined'
// error - to avoid it I just create them as inner functions.
func adjustRegionNetworkFirewallPolicyRuleNetworkContextFields(obj map[string]interface{}, oldMatch interface{}, newMatch interface{}) error {
	adjustFieldsFunc := func(match map[string]interface{}, fieldName1 string, fieldName2 string) error {
		getFieldValueFunc := func(match any, fieldName string) string {
			// Extract the nested field value from the old match
			if valuesList := match.([]interface{}); len(valuesList) > 0 {
				if data := valuesList[0].(map[string]interface{}); data != nil {
					if val, ok := data[fieldName].(string); ok {
						return val
					}
				}
			}
			return ""
		}

		oldField1 := getFieldValueFunc(oldMatch, fieldName1)
		newField1 := getFieldValueFunc(newMatch, fieldName1)
		oldField2 := getFieldValueFunc(oldMatch, fieldName2)
		newField2 := getFieldValueFunc(newMatch, fieldName2)

		field1Changed := newField1 != oldField1
		field2Changed := newField2 != oldField2

		if field1Changed && field2Changed {
			// it should not be possible because one cannot use both fields at the same time (using 'conflicts' in schema)
			return fmt.Errorf("Cannot change both %s and %s at the same time", fieldName1, fieldName2)
		}

		if field1Changed {
			delete(match, fieldName2)
		} else if field2Changed {
			delete(match, fieldName1)
		}
		return nil
	}

	match, exists := obj["match"]

	if !exists {
	  return nil
	}

	err := adjustFieldsFunc(match.(map[string]interface{}), "src_network_scope", "src_network_context")
	if err != nil {
		return err
	}
	err = adjustFieldsFunc(match.(map[string]interface{}), "dest_network_scope", "dest_network_context")
	if err != nil {
		return err
	}
	return nil
}
