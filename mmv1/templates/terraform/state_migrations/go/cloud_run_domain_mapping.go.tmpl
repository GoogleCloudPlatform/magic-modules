var domainMappingGoogleProvidedLocationLabel = "cloud.googleapis.com/location"
var domainMappingGoogleProvidedOverrideLabel = "run.googleapis.com/overrideAt"

var domainMappingGoogleProvidedLabels = []string{
	domainMappingGoogleProvidedLocationLabel,
	domainMappingGoogleProvidedOverrideLabel,
}

func DomainMappingLabelDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the labels provided by Google
	for _, label := range domainMappingGoogleProvidedLabels {
		if strings.Contains(k, label) && new == "" {
			return true
		}
	}

	// Let diff be determined by labels (above)
	if strings.Contains(k, "labels.%") {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

func resourceCloudRunDomainMappingResourceV0() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the cloud run instance. eg us-central1`,
			},
			"metadata": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `Metadata associated with this DomainMapping.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"namespace": {
							Type:     schema.TypeString,
							Required: true,
							ForceNew: true,
							Description: `In Cloud Run the namespace must be equal to either the
project ID or project number.`,
						},
						"annotations": {
							Type:             schema.TypeMap,
							Computed:         true,
							Optional:         true,
							ForceNew:         true,
							DiffSuppressFunc: cloudrunAnnotationDiffSuppress,
							Description: `Annotations is a key value map stored with a resource that
may be set by external tools to store and retrieve arbitrary metadata. More
info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations

**Note**: The Cloud Run API may add additional annotations that were not provided in your config.
If terraform plan shows a diff where a server-side annotation is added, you can add it to your config
or apply the lifecycle.ignore_changes rule to the metadata.0.annotations field.`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
						"labels": {
							Type:             schema.TypeMap,
							Computed:         true,
							Optional:         true,
							ForceNew:         true,
							DiffSuppressFunc: DomainMappingLabelDiffSuppress,
							Description: `Map of string keys and values that can be used to organize and categorize
(scope and select) objects. May match selectors of replication controllers
and routes.
More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
						"generation": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `A sequence number representing a specific generation of the desired state.`,
						},
						"resource_version": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `An opaque value that represents the internal version of this object that
can be used by clients to determine when objects have changed. May be used
for optimistic concurrency, change detection, and the watch operation on a
resource or set of resources. They may only be valid for a
particular resource or set of resources.

More info:
https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency`,
						},
						"self_link": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `SelfLink is a URL representing this object.`,
						},
						"uid": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `UID is a unique id generated by the server on successful creation of a resource and is not
allowed to change on PUT operations.

More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids`,
						},
					},
				},
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Name should be a [verified](https://support.google.com/webmasters/answer/9008080) domain`,
			},
			"spec": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `The spec for this DomainMapping.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"route_name": {
							Type:             schema.TypeString,
							Required:         true,
							ForceNew:         true,
							DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
							Description: `The name of the Cloud Run Service that this DomainMapping applies to.
The route must exist.`,
						},
						"certificate_mode": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"NONE", "AUTOMATIC", ""}),
							Description:  `The mode of the certificate. Default value: "AUTOMATIC" Possible values: ["NONE", "AUTOMATIC"]`,
							Default:      "AUTOMATIC",
						},
						"force_override": {
							Type:     schema.TypeBool,
							Optional: true,
							ForceNew: true,
							Description: `If set, the mapping will override any mapping set before this spec was set.
It is recommended that the user leaves this empty to receive an error
warning about a potential conflict and only set it once the respective UI
has given such a warning.`,
						},
					},
				},
			},
			"status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The current status of the DomainMapping.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"resource_records": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `The resource records required to configure this domain mapping. These
records must be added to the domain's DNS configuration in order to
serve the application via this domain mapping.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"type": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"A", "AAAA", "CNAME", ""}),
										Description:  `Resource record type. Example: 'AAAA'. Possible values: ["A", "AAAA", "CNAME"]`,
									},
									"name": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Relative name of the object affected by this record. Only applicable for
'CNAME' records. Example: 'www'.`,
									},
									"rrdata": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Data for this record. Values vary by record type, as defined in RFC 1035
(section 5) and RFC 1034 (section 3.6.1).`,
									},
								},
							},
						},
						"conditions": {
							Type:     schema.TypeList,
							Computed: true,
							Description: `Array of observed DomainMappingConditions, indicating the current state
of the DomainMapping.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"message": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Human readable message indicating details about the current status.`,
									},
									"reason": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `One-word CamelCase reason for the condition's current status.`,
									},
									"status": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Status of the condition, one of True, False, Unknown.`,
									},
									"type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Type of domain mapping condition.`,
									},
								},
							},
						},
						"mapped_route_name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The name of the route that the mapping currently points to.`,
						},
						"observed_generation": {
							Type:     schema.TypeInt,
							Computed: true,
							Description: `ObservedGeneration is the 'Generation' of the DomainMapping that
was last processed by the controller.`,
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func ResourceCloudRunDomainMappingUpgradeV0(_ context.Context, rawState map[string]interface{}, meta interface{}) (map[string]interface{}, error) {
	log.Printf("[DEBUG] Attributes before migration: %#v", rawState)

	if rawState["metadata"] != nil {
		rawMetadatas := rawState["metadata"].([]interface{})
		if len(rawMetadatas) > 0 && rawMetadatas[0] != nil {
			// Upgrade labels fields
			rawMetadata := rawMetadatas[0].(map[string]interface{})

			rawLabels := rawMetadata["labels"]
			rawTerraformLabels := rawMetadata["terraform_labels"]
			if rawLabels != nil {
				labels := make(map[string]interface{})
				effectiveLabels := make(map[string]interface{})

				for k, v := range rawLabels.(map[string]interface{}) {
					effectiveLabels[k] = v

					if !strings.Contains(k, domainMappingGoogleProvidedLocationLabel) && !strings.Contains(k, domainMappingGoogleProvidedOverrideLabel) {
						labels[k] = v
					}
				}

				rawMetadata["labels"] = labels
				rawMetadata["effective_labels"] = effectiveLabels

				if rawTerraformLabels == nil {
					rawMetadata["terraform_labels"] = labels
				}
			}

			upgradeAnnotations(rawMetadata)

			rawState["metadata"] = []interface{}{rawMetadata}
		}
	}

	log.Printf("[DEBUG] Attributes after migration: %#v", rawState)
	return rawState, nil
}
