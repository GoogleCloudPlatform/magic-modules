// if gke clusters are attached, they need to be detached before the response policy can be deleted
if d.Get("gke_clusters.#").(int) > 0 {
	patched := make(map[string]interface{})
	patched["gkeClusters"] = nil

	url, err := tpgresource.ReplaceVars(d, config, "{{DNSBasePath}}projects/{{project}}/responsePolicies/{{response_policy_name}}")
	if err != nil {
		return err
	}

	_, err = transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config: config,
		Method: "PATCH",
		Project: project,
		RawURL: url,
		UserAgent: userAgent,
		Body: patched,
		Timeout: d.Timeout(schema.TimeoutUpdate),
<% if object.error_retry_predicates -%>
		ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{<%= object.error_retry_predicates.join(',') -%>},
<% end -%>
	})
	if err != nil {
		return fmt.Errorf("Error updating Policy %q: %s", d.Id(), err)
	}
}

// if networks are attached, they need to be detached before the response policy can be deleted
if d.Get("networks.#").(int) > 0 {
	patched := make(map[string]interface{})
	patched["networks"] = nil

	url, err := tpgresource.ReplaceVars(d, config, "{{DNSBasePath}}projects/{{project}}/responsePolicies/{{response_policy_name}}")
	if err != nil {
		return err
	}

	_, err = transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config: config,
		Method: "PATCH",
		Project: project,
		RawURL: url,
		UserAgent: userAgent,
		Body: patched,
		Timeout: d.Timeout(schema.TimeoutUpdate),
<% if object.error_retry_predicates -%>
		ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{<%= object.error_retry_predicates.join(',') -%>},
<% end -%>
	})
	if err != nil {
		return fmt.Errorf("Error updating Policy %q: %s", d.Id(), err)
	}
}
