// A replication can only be deleted if mirrorState==STOPPED
// We are about to delete the replication and need to stop the mirror before.
// FYI: Stopping a PREPARING mirror currently doesn't work. User have to wait until
// mirror reaches MIRRORED.
if d.Get("mirror_state") != "STOPPED" {
	rawurl, err := tpgresource.ReplaceVars(d, config, "{{NetappBasePath}}projects/{{project}}/locations/{{location}}/volumes/{{volume_name}}/replications/{{name}}:stop")
	if err != nil {
			return err
		}

	reso, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config: config,
		Method: "POST",
		Project: billingProject,
		RawURL: rawurl,
		UserAgent: userAgent,
		// We delete anyway, so lets always use force stop
		Body: map[string]interface{}{
			"force": true,
		},
		Timeout: d.Timeout(schema.TimeoutUpdate),
	<% if object.error_retry_predicates -%>
			ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{<%= object.error_retry_predicates.join(',') -%>},
	<% end -%>
	<% if object.error_abort_predicates -%>
			ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{<%= object.error_abort_predicates.join(',') -%>},
	<% end -%>
	})
	if err != nil {
		return fmt.Errorf("Error stopping volumereplication %q before deleting it: %s", d.Id(), err)
	}

	err = NetappOperationWaitTime(
					config, reso, project, "Deleting volumereplication", userAgent,
					d.Timeout(schema.TimeoutDelete))
	if err != nil {
			return err
	}
}