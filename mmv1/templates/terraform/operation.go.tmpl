{{/* TODO: if hc_downstream */ -}}
// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package {{ lower $.ProductMetadata.Name }}

import (
  "encoding/json"
  "errors"
  "fmt"
  "time"

  "{{ $.ImportPath }}/tpgresource"
  transport_tpg "{{ $.ImportPath }}/transport"
)

type {{ $.ProductMetadata.Name }}OperationWaiter struct {
  Config    *transport_tpg.Config
  UserAgent string
{{- if $.IncludeProjectForOperation }}
  Project string
{{- end }}
{{- if $.ProductMetadata.OperationRetry }}
  retryCount int
{{- end }}
  tpgresource.CommonOperationWaiter
}

func (w *{{ $.ProductMetadata.Name }}OperationWaiter) QueryOp() (interface{}, error) {
  if w == nil {
    return nil, fmt.Errorf("Cannot query operation, it's unset or nil.")
  }
  // Returns the proper get.
  {{- if $.GetAsync.Operation.FullUrl }}
  url := fmt.Sprintf("{{ replaceAll $.GetAsync.Operation.FullUrl "{{op_id}}" "%s" }}", w.CommonOperationWaiter.Op.Name)
  {{- else }}
  url := fmt.Sprintf("%s{{ replaceAll $.GetAsync.Operation.BaseUrl "{{op_id}}" "%s" }}", w.Config.{{ $.ProductMetadata.Name }}BasePath, w.CommonOperationWaiter.Op.Name)
  {{- end }}

  return transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
    Config: w.Config,
    Method: "GET",
    {{- if $.IncludeProjectForOperation }}
    Project: w.Project,
    {{- end }}
    RawURL: url,
    UserAgent: w.UserAgent,
    {{- if $.ErrorRetryPredicates }}
    ErrorRetryPredicates: []transport_tpg.RetryErrorPredicateFunc{ {{- join $.ErrorRetryPredicates "," -}} },
    {{- end }}
    {{- if $.ErrorAbortPredicates }}
    ErrorAbortPredicates: []transport_tpg.RetryErrorPredicateFunc{ {{- join $.ErrorAbortPredicates "," -}} },
    {{- end }}
  })
}

{{- if $.ProductMetadata.OperationRetry }}
func (w *{{ $.ProductMetadata.Name }}OperationWaiter) IsRetryable(err error) bool {
  {{- $.CustomTemplate $.ProductMetadata.OperationRetry false }}
}
{{- end }}


func create{{ $.ProductMetadata.Name }}Waiter(config *transport_tpg.Config, op map[string]interface{}, {{- if $.IncludeProjectForOperation }} project, {{- end }} activity, userAgent string) (*{{ $.ProductMetadata.Name }}OperationWaiter, error) {
  w := &{{ $.ProductMetadata.Name }}OperationWaiter{
    Config:    config,
    UserAgent: userAgent,
{{- if $.IncludeProjectForOperation }}
    Project: project,
{{- end }}
  }
  if err := w.CommonOperationWaiter.SetOp(op); err != nil {
    return nil, err
  }
  return w, nil
}

{{/* Not all APIs will need a WithResponse operation, but it's hard to check whether
    they will or not since it involves iterating over all resources.
    Might as well just nolint it so we can pass the linter checks.
*/}}

// nolint: deadcode,unused {{/* TODO: remove the comment */}}
func {{ camelize $.ProductMetadata.Name "upper" }}OperationWaitTimeWithResponse(config *transport_tpg.Config, op map[string]interface{}, response *map[string]interface{},{{- if $.IncludeProjectForOperation }} project,{{- end }} activity, userAgent string, timeout time.Duration) error {
  w, err := create{{ $.ProductMetadata.Name }}Waiter(config, op, {{- if $.IncludeProjectForOperation }} project, {{ end }} activity, userAgent)
  if err != nil {
      return err
  }
  if err := tpgresource.OperationWait(w, activity, timeout, config.PollInterval); err != nil {
      return err
  }
  rawResponse := []byte(w.CommonOperationWaiter.Op.Response)
  if len(rawResponse) == 0 {
    return errors.New("`resource` not set in operation response")
  }
  return json.Unmarshal(rawResponse, response)
}

func {{ camelize $.ProductMetadata.Name "upper" }}OperationWaitTime(config *transport_tpg.Config, op map[string]interface{}, {{- if $.IncludeProjectForOperation }} project,{{- end }} activity, userAgent string, timeout time.Duration) error {
  if val, ok := op["name"]; !ok || val == "" {
    // This was a synchronous call - there is no operation to wait for.
    return nil
  }
  w, err := create{{ $.ProductMetadata.Name }}Waiter(config, op, {{- if $.IncludeProjectForOperation }} project, {{ end }} activity, userAgent)
  if err != nil {
      // If w is nil, the op was synchronous.
      return err
  }
  return tpgresource.OperationWait(w, activity, timeout, config.PollInterval)
}
