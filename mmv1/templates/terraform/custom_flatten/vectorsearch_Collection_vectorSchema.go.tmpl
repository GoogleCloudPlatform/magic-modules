func flatten{{$.GetPrefix}}{{$.TitlelizeProperty}}(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) interface{} {
  if v == nil {
    return nil
  }

  apiMap, ok := v.(map[string]interface{})
  if !ok || len(apiMap) == 0 {
    return nil
  }

  tfList := make([]interface{}, 0, len(apiMap))

  // Sort keys to ensure consistent order in Terraform state
  var sortedKeys []string
  for k := range apiMap {
    sortedKeys = append(sortedKeys, k)
  }
  sort.Strings(sortedKeys)

  for _, fieldName := range sortedKeys {
    val := apiMap[fieldName]
    itemMap := make(map[string]interface{})
    itemMap["field_name"] = fieldName

    valMap, ok := val.(map[string]interface{})
    if !ok {
      continue // Should not happen based on API structure
    }

    if denseV, exists := valMap["denseVector"]; exists {
      itemMap["dense_vector"] = flatten{{$.GetPrefix}}{{$.TitlelizeProperty}}DenseVector(denseV)
      itemMap["sparse_vector"] = make([]interface{}, 0) // Ensure the other block is empty
    } else if _, exists := valMap["sparseVector"]; exists {
      itemMap["sparse_vector"] = []interface{}{make(map[string]interface{})} // Represents an empty block
      itemMap["dense_vector"] = make([]interface{}, 0)   // Ensure the other block is empty
    }
    tfList = append(tfList, itemMap)
  }

  return tfList
}

// Helper function to flatten the dense_vector structure
func flatten{{$.GetPrefix}}{{$.TitlelizeProperty}}DenseVector(v interface{}) []interface{} {
  if v == nil {
    return make([]interface{}, 0)
  }
  data, ok := v.(map[string]interface{})
  if !ok {
    return make([]interface{}, 0)
  }

  denseMap := make(map[string]interface{})
  if dim, ok := data["dimensions"]; ok {
    denseMap["dimensions"] = int(dim.(float64)) // API JSON numbers are float64
  }

  if vecIntf, ok := data["vertexEmbeddingConfig"]; ok {
    vecData, ok := vecIntf.(map[string]interface{})
    if ok {
      vecMap := make(map[string]interface{})
      if modelId, ok := vecData["modelId"].(string); ok {
        vecMap["model_id"] = modelId
      }
      if taskType, ok := vecData["taskType"].(string); ok {
        vecMap["task_type"] = taskType
      }
      if textTemplate, ok := vecData["textTemplate"].(string); ok {
        vecMap["text_template"] = textTemplate
      }
      denseMap["vertex_embedding_config"] = []interface{}{vecMap}
    } else {
      denseMap["vertex_embedding_config"] = make([]interface{}, 0)
    }
  } else {
    denseMap["vertex_embedding_config"] = make([]interface{}, 0)
  }

  return []interface{}{denseMap}
}
