
if d.HasChange("replica_action") {
	obj := make(map[string]interface{})
	endpoint := ""
	replica_action_value := ""

	replicaActionProp := d.Get("replica_action")
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("replica_action"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, replicaActionProp)) {
		obj["replicaAction"] = replicaActionProp
	}

	switch replicaActionProp {
	case "PAUSE":
		endpoint = "pauseReplica"
		replica_action_value = "PAUSE"
	case "RESUME":
		endpoint = "resumeReplica"
		replica_action_value = "RESUME"
	case "":
		return fmt.Errorf("Error: replica_action cannot be empty")
	}

	url, err := tpgresource.ReplaceVars(d, config, fmt.Sprintf("{{"{{"}}{{$.ProductMetadata.Name}}BasePath{{"}}"}}{{$.SelfLinkUri}}:%s",endpoint))
		if err != nil {
			return err
		}

		headers := make(http.Header)

		emptyReqBody := make(map[string]interface{})
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "POST",
			Project:   project,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      emptyReqBody,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
			Headers:   headers,
		})
		if err != nil {
			return fmt.Errorf("Error Pausing/Resuming Instance %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished Pausing/Resuming Instance %q: %#v", d.Id(), res)
		}

		err = FilestoreOperationWaitTime(
			config, res, project, "Pausing/Resuming Instance", userAgent,
			d.Timeout(schema.TimeoutUpdate))
		if err != nil {
			return err
		}

		d.Set("replica_action", replica_action_value)
	}