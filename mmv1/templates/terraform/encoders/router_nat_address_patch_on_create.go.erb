currItems, err := resourceComputeRouterNatAddressListForPatch(d, meta)
if err != nil {
	return nil, err
}

idx, found, err := resourceComputeRouterNatAddressFindNestedObjectInList(d, meta, currItems)
if err != nil {
	return nil, err
}

// Merge new with existing item if item was already created (with the router nat resource).
if found != nil {
	log.Printf("[WARNING] Existing RouterNatAddress object already found: %+v \n Update: %+v", found, obj)

	// Merge new object into old.
	for k, v := range obj {
		found[k] = v
	}
	currItems[idx] = found

	// Return list with new item added
	resPatch := map[string]interface{}{
		"nats": currItems,
	}

	return resPatch, nil
}

// Return list with the resource to create appended
res := map[string]interface{}{
	"nats": append(currItems, obj),
}

return res, nil
