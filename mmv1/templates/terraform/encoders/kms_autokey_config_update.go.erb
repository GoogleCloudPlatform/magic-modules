// Build request body and update mask for AutokeyConfig PATCH.

// The encoder should only build and return the request body. The Update
// function's custom_update template handles URL/update_mask and sending the
// request. Avoid redeclaring scaffold locals here.

// The generated Update function provides `meta` as an interface{}; decode
// it here so the encoder can call expand* helpers that require the config.
config := meta.(*transport_tpg.Config)

body := make(map[string]interface{})

if d.HasChange("key_project") {
    // Use the same expansion + IsEmptyValue logic as Create to avoid sending
    // an empty string. This treats empty/zero values as unset.
    keyProjectProp, _ := expandKMSAutokeyConfigKeyProject(d.Get("key_project"), d, config)
    if v, ok := d.GetOkExists("key_project"); !tpgresource.IsEmptyValue(reflect.ValueOf(keyProjectProp)) && (ok || !reflect.DeepEqual(v, keyProjectProp)) {
        body["keyProject"] = keyProjectProp
    } else {
        body["keyProject"] = nil
    }
}

if d.HasChange("same_project_autokey") {
    sameProjectAutokeyProp, _ := expandKMSAutokeyConfigSameProjectAutokey(d.Get("same_project_autokey"), d, config)
    if v, ok := d.GetOkExists("same_project_autokey"); !tpgresource.IsEmptyValue(reflect.ValueOf(sameProjectAutokeyProp)) && (ok || !reflect.DeepEqual(v, sameProjectAutokeyProp)) {
        body["sameProjectAutokey"] = sameProjectAutokeyProp
    } else {
        body["sameProjectAutokey"] = nil
    }
}

return body, nil