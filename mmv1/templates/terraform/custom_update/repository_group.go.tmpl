userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
if err != nil {
	return err
}

billingProject := ""

project, err := tpgresource.GetProject(d, config)
if err != nil {
	return fmt.Errorf("Error fetching project for RepositoryGroup: %s", err)
}
billingProject = project

obj := make(map[string]interface{})
repositoriesProp, err := expandGeminiRepositoryGroupRepositories(d.Get("repositories"), d, config)
if err != nil {
	return err
} else if v, ok := d.GetOkExists("repositories"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, repositoriesProp)) {
	obj["repositories"] = repositoriesProp
}
labelsProp, err := expandGeminiRepositoryGroupEffectiveLabels(d.Get("effective_labels"), d, config)
if err != nil {
	return err
} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
	obj["labels"] = labelsProp
}

url, err := tpgresource.ReplaceVars(d, config, "{{"{{"}}GeminiBasePath{{"}}"}}projects/{{"{{"}}project{{"}}"}}/locations/{{"{{"}}location{{"}}"}}/codeRepositoryIndexes/{{"{{"}}code_repository_index_id{{"}}"}}/repositoryGroups/{{"{{"}}repository_group_id{{"}}"}}")
if err != nil {
	return err
}

log.Printf("[DEBUG] Updating RepositoryGroup %q: %#v", d.Id(), obj)

// err == nil indicates that the billing_project value was found
if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
	billingProject = bp
}

var res map[string]interface{}
headers := make(http.Header)
for {
	res, err = transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "PUT",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutUpdate),
		Headers:   headers,
	})
	if err != nil {
		if transport_tpg.IsGoogleApiErrorWithCode(err, 409) {
			errMsg := fmt.Sprintf("%s", err)
			if strings.Contains(errMsg, "unable to queue the operation") {
				log.Printf("[DEBUG] Waiting for enqueued operation to finish before updating RepositoryGroup: %#v", obj)
				time.Sleep(10 * time.Second)
			} else if strings.Contains(errMsg, "parent resource not in ready state") {
				log.Printf("[DEBUG] Waiting for parent resource to become active before updating RepositoryGroup: %#v", obj)
				time.Sleep(1 * time.Minute)
			} else {
				return fmt.Errorf("Error updating RepositoryGroup %q: %s", d.Id(), err)
			}
		} else {
			return fmt.Errorf("Error updating RepositoryGroup %q: %s", d.Id(), err)
		}
	} else {
		break
	}
}
log.Printf("[DEBUG] Finished updating RepositoryGroup %q: %#v", d.Id(), res)

err = GeminiOperationWaitTime(
	config, res, project, "Updating RepositoryGroup", userAgent,
	d.Timeout(schema.TimeoutUpdate))

if err != nil {
	return err
}

return resourceGeminiRepositoryGroupRead(d, meta)