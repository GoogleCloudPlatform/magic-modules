nsRaw := d.Get("namespace").([]interface{})
	ns := make([]string, len(nsRaw))
	for i, v := range nsRaw {
		ns[i] = v.(string)
	}

	if d.HasChange("properties") {
		oldProp, newProp := d.GetChange("properties")
		oldMap := oldProp.(map[string]interface{})
		newMap := newProp.(map[string]interface{})

		removals := []string{}
		for k := range oldMap {
			if isIgnoredProperty(k) {
				continue
			}
			if _, ok := newMap[k]; !ok {
				removals = append(removals, k)
			}
		}

		updates := map[string]string{}
		for k, v := range newMap {
			if isIgnoredProperty(k) {
				continue
			}
			updates[k] = v.(string)
		}

		body := map[string]interface{}{
			"removals": removals,
			"updates":  updates,
		}

		url, err := tpgresource.ReplaceVars(d, config, fmt.Sprintf("{{ "{{" }}BiglakeIcebergBasePath{{ "}}" }}iceberg/v1/restcatalog/v1/projects/{{ "{{" }}project{{ "}}" }}/catalogs/{{ "{{" }}catalog{{ "}}" }}/namespaces/%s/properties", encodeNamespace(ns)))
		if err != nil {
			return err
		}

		_, err = transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "POST",
			RawURL:    url,
			UserAgent: config.UserAgent,
			Body:      body,
		})
		if err != nil {
			return fmt.Errorf("Error updating IcebergNamespace properties: %s", err)
		}
	}

	return resourceBiglakeIcebergIcebergNamespaceRead(d, meta)