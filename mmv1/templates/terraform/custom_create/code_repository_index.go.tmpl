userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
if err != nil {
	return err
}

obj := make(map[string]interface{})
kmsKeyProp, err := expandGeminiCodeRepositoryIndexKmsKey(d.Get("kms_key"), d, config)
if err != nil {
	return err
} else if v, ok := d.GetOkExists("kms_key"); !tpgresource.IsEmptyValue(reflect.ValueOf(kmsKeyProp)) && (ok || !reflect.DeepEqual(v, kmsKeyProp)) {
	obj["kmsKey"] = kmsKeyProp
}
labelsProp, err := expandGeminiCodeRepositoryIndexEffectiveLabels(d.Get("effective_labels"), d, config)
if err != nil {
	return err
} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
	obj["labels"] = labelsProp
}

url, err := tpgresource.ReplaceVars(d, config, "{{"{{"}}GeminiBasePath{{"}}"}}projects/{{"{{"}}project{{"}}"}}/locations/{{"{{"}}location{{"}}"}}/codeRepositoryIndexes?codeRepositoryIndexId={{"{{"}}code_repository_index_id{{"}}"}}")
if err != nil {
	return err
}

log.Printf("[DEBUG] Creating new CodeRepositoryIndex: %#v", obj)
billingProject := ""

project, err := tpgresource.GetProject(d, config)
if err != nil {
	return fmt.Errorf("Error fetching project for CodeRepositoryIndex: %s", err)
}
billingProject = project

// err == nil indicates that the billing_project value was found
if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
	billingProject = bp
}

var res map[string]interface{}
headers := make(http.Header)
for {
	res, err = transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		if transport_tpg.IsGoogleApiErrorWithCode(err, 409) {
			log.Printf("[DEBUG] Waiting for enqueued operation to finish before creating CodeRepositoryIndex: %#v", obj)
			time.Sleep(3 * time.Minute)
		} else {
			return fmt.Errorf("Error creating CodeRepositoryIndex: %s", err)
		}
	} else {
		break
	}
}

// Store the ID now
id, err := tpgresource.ReplaceVars(d, config, "projects/{{"{{"}}project{{"}}"}}/locations/{{"{{"}}location{{"}}"}}/codeRepositoryIndexes/{{"{{"}}code_repository_index_id{{"}}"}}")
if err != nil {
	return fmt.Errorf("Error constructing id: %s", err)
}
d.SetId(id)

// Use the resource in the operation response to populate
// identity fields and d.Id() before read
var opRes map[string]interface{}
err = GeminiOperationWaitTimeWithResponse(
	config, res, &opRes, project, "Creating CodeRepositoryIndex", userAgent,
	d.Timeout(schema.TimeoutCreate))
if err != nil {
	// The resource didn't actually create
	d.SetId("")

	return fmt.Errorf("Error waiting to create CodeRepositoryIndex: %s", err)
}

if err := d.Set("name", flattenGeminiCodeRepositoryIndexName(opRes["name"], d, config)); err != nil {
	return err
}

// This may have caused the ID to update - update it if so.
id, err = tpgresource.ReplaceVars(d, config, "projects/{{"{{"}}project{{"}}"}}/locations/{{"{{"}}location{{"}}"}}/codeRepositoryIndexes/{{"{{"}}code_repository_index_id{{"}}"}}")
if err != nil {
	return fmt.Errorf("Error constructing id: %s", err)
}
d.SetId(id)

url, err = tpgresource.ReplaceVars(d, config, "{{"{{"}}GeminiBasePath{{"}}"}}projects/{{"{{"}}project{{"}}"}}/locations/{{"{{"}}location{{"}}"}}/codeRepositoryIndexes/{{"{{"}}code_repository_index_id{{"}}"}}")
if err != nil {
	return fmt.Errorf("Error constructing url: %s", err)
}
for {
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		fmt.Errorf("Error getting new CodeRepositoryIndex %q: %s", d.Id(), err)
	}
	if res["state"] == "CREATING" {
		time.Sleep(1 * time.Minute)
	} else {
		log.Printf("[DEBUG] Waiting for CodeRepositoryIndex to change state from \"CREATING\" finished")
		break
	}
}

log.Printf("[DEBUG] Finished creating CodeRepositoryIndex %q: %#v", d.Id(), res)

return resourceGeminiCodeRepositoryIndexRead(d, meta)