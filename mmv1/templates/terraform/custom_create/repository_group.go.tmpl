userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
if err != nil {
	return err
}

obj := make(map[string]interface{})
repositoriesProp, err := expandGeminiRepositoryGroupRepositories(d.Get("repositories"), d, config)
if err != nil {
	return err
} else if v, ok := d.GetOkExists("repositories"); !tpgresource.IsEmptyValue(reflect.ValueOf(repositoriesProp)) && (ok || !reflect.DeepEqual(v, repositoriesProp)) {
	obj["repositories"] = repositoriesProp
}
labelsProp, err := expandGeminiRepositoryGroupEffectiveLabels(d.Get("effective_labels"), d, config)
if err != nil {
	return err
} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
	obj["labels"] = labelsProp
}

url, err := tpgresource.ReplaceVars(d, config, "{{"{{"}}GeminiBasePath{{"}}"}}projects/{{"{{"}}project{{"}}"}}/locations/{{"{{"}}location{{"}}"}}/codeRepositoryIndexes/{{"{{"}}coderepositoryindex{{"}}"}}/repositoryGroups?repositoryGroupId={{"{{"}}repository_group_id{{"}}"}}")
if err != nil {
	return err
}

log.Printf("[DEBUG] Creating new RepositoryGroup: %#v", obj)
billingProject := ""

project, err := tpgresource.GetProject(d, config)
if err != nil {
	return fmt.Errorf("Error fetching project for RepositoryGroup: %s", err)
}
billingProject = project

// err == nil indicates that the billing_project value was found
if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
	billingProject = bp
}

var res map[string]interface{}
headers := make(http.Header)
for {
	res, err = transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		if transport_tpg.IsGoogleApiErrorWithCode(err, 409) {
			errMsg := fmt.Sprintf("%s", err)
			if strings.Contains(errMsg, "unable to queue the operation") {
				log.Printf("[DEBUG] Waiting for enqueued operation to finish before creating RepositoryGroup: %#v", obj)
				time.Sleep(10 * time.Second)
			} else if strings.Contains(errMsg, "parent resource not in ready state") {
				log.Printf("[DEBUG] Waiting for parent resource to become active before creating RepositoryGroup: %#v", obj)
				time.Sleep(1 * time.Minute)
			} else {
				return fmt.Errorf("Error creating RepositoryGroup %q: %s", d.Id(), err)
			}
		} else {
			return fmt.Errorf("Error creating RepositoryGroup: %s", err)
		}
	} else {
		break
	}
}

// Store the ID now
id, err := tpgresource.ReplaceVars(d, config, "projects/{{"{{"}}project{{"}}"}}/locations/{{"{{"}}location{{"}}"}}/codeRepositoryIndexes/{{"{{"}}coderepositoryindex{{"}}"}}/repositoryGroups/{{"{{"}}repository_group_id{{"}}"}}")
if err != nil {
	return fmt.Errorf("Error constructing id: %s", err)
}
d.SetId(id)

// Use the resource in the operation response to populate
// identity fields and d.Id() before read
var opRes map[string]interface{}
err = GeminiOperationWaitTimeWithResponse(
	config, res, &opRes, project, "Creating RepositoryGroup", userAgent,
	d.Timeout(schema.TimeoutCreate))
if err != nil {
	// The resource didn't actually create
	d.SetId("")

	return fmt.Errorf("Error waiting to create RepositoryGroup: %s", err)
}

if err := d.Set("name", flattenGeminiRepositoryGroupName(opRes["name"], d, config)); err != nil {
	return err
}

// This may have caused the ID to update - update it if so.
id, err = tpgresource.ReplaceVars(d, config, "projects/{{"{{"}}project{{"}}"}}/locations/{{"{{"}}location{{"}}"}}/codeRepositoryIndexes/{{"{{"}}coderepositoryindex{{"}}"}}/repositoryGroups/{{"{{"}}repository_group_id{{"}}"}}")
if err != nil {
	return fmt.Errorf("Error constructing id: %s", err)
}
d.SetId(id)

log.Printf("[DEBUG] Finished creating RepositoryGroup %q: %#v", d.Id(), res)

return resourceGeminiRepositoryGroupRead(d, meta)