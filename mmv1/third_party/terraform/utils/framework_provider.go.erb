<% autogen_exception -%>
package google

import (
    "context"
    "fmt"
    "net/http"
    "os"
    "time"

    grpc_logrus "github.com/grpc-ecosystem/go-grpc-middleware/logging/logrus"
    "github.com/hashicorp/terraform-plugin-framework/datasource"
    "github.com/hashicorp/terraform-plugin-framework/path"
    "github.com/hashicorp/terraform-plugin-framework/provider"
    "github.com/hashicorp/terraform-plugin-framework/provider/schema"
    "github.com/hashicorp/terraform-plugin-framework/resource"
    "github.com/hashicorp/terraform-plugin-framework/schema/validator"
    "github.com/hashicorp/terraform-plugin-framework/types"
    "github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
    "github.com/sirupsen/logrus"

    "google.golang.org/api/option"
    "google.golang.org/grpc"
)

// Ensure the implementation satisfies the expected interfaces
var (
    _ provider.Provider = &frameworkProvider{}

    defaultClientScopes = []string{
        "https://www.googleapis.com/auth/cloud-platform",
        "https://www.googleapis.com/auth/userinfo.email",
    }
)

// New is a helper function to simplify provider server and testing implementation.
func New(version string) provider.Provider {
    return &frameworkProvider{
        version: version,
    }
}

// frameworkProvider is the provider implementation.
type frameworkProvider struct{
    client *http.Client
    context context.Context
    gRPCLoggingOptions []option.ClientOption
    pollInterval time.Duration
    region string
    requestBatcherIam *RequestBatcher
    requestBatcherServiceUsage *RequestBatcher
    scopes []string
    userAgent string
    userProjectOverride bool
    version string
}

// Metadata returns the provider type name.
func (p *frameworkProvider) Metadata(_ context.Context, _ provider.MetadataRequest, resp *provider.MetadataResponse) {
    resp.TypeName = "google<%= "-" + version unless version == 'ga'  -%>"
    resp.Version = p.version
}

// Schema defines the provider-level schema for configuration data.
func (p *frameworkProvider) Schema(_ context.Context, _ provider.SchemaRequest, resp *provider.SchemaResponse) {
    resp.Schema = schema.Schema{
        Attributes: map[string]schema.Attribute{
            "credentials": schema.StringAttribute{
                Optional: true,
                // ValidateFunc: validateCredentials,
                Validators: []validator.String{
                    stringvalidator.ConflictsWith(path.Expressions{
                        path.MatchRoot("access_token"),
                    }...),
                },
            },
            "access_token": schema.StringAttribute{
                Optional: true,
                Validators: []validator.String{
                    stringvalidator.ConflictsWith(path.Expressions{
                        path.MatchRoot("access_token"),
                    }...),
                },
            },
            "impersonate_service_account": schema.StringAttribute{
                Optional: true,
            },
            "impersonate_service_account_delegates": schema.ListAttribute{
                Optional:    true,
                ElementType: types.StringType,
            },
            "project": schema.StringAttribute{
                Optional: true,
            },
            "billing_project": schema.StringAttribute{
                Optional: true,
            },
            "region": schema.StringAttribute{
                Optional: true,
            },
            "zone": schema.StringAttribute{
                Optional: true,
            },
            "scopes": schema.ListAttribute{
                Optional:    true,
                ElementType: types.StringType,
            },
            "user_project_override": schema.BoolAttribute{
                Optional: true,
            },
            "request_timeout": schema.StringAttribute{
                Optional: true,
            },
            "request_reason": schema.StringAttribute{
                Optional: true,
            },
        },
        Blocks: map[string]schema.Block{
            "batching": schema.SingleNestedBlock{
                Attributes: map[string]schema.Attribute{
                    "send_after": schema.StringAttribute{
                        Optional: true,
                        // ValidateFunc: validateNonNegativeDuration(),
                    },
                    "enable_batching": schema.BoolAttribute{
                        Optional: true,
                    },
                },
            },
        },
    }
}

// Configure prepares an API client for data sources and resources.
func (p *frameworkProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) {
    var data ProviderModel

    resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)

    if resp.Diagnostics.HasError() {
        return
    }

    // Configuration values are now available.

    // Set defaults if needed
    p.HandleDefaults(ctx, &data, &resp.Diagnostics)
    if resp.Diagnostics.HasError() {
        return
    }

    
    // Handle User Agent string
    p.userAgent = CompileUserAgentString("terraform-provider-google<%= "-" + version unless version == 'ga'  -%>", req.TerraformVersion, p.version)
    // opt in extension for adding to the User-Agent header
    if ext := os.Getenv("GOOGLE_TERRAFORM_USERAGENT_EXTENSION"); ext != "" {
        ua := p.userAgent
        p.userAgent = fmt.Sprintf("%s %s", ua, ext)
    }

    // Set up client configuration
    p.SetupClient(ctx, data, &resp.Diagnostics)
    if resp.Diagnostics.HasError() {
        return
    }

    // gRPC Logging setup
    logger := logrus.StandardLogger()

    logrus.SetLevel(logrus.DebugLevel)
    logrus.SetFormatter(&Formatter{
        TimestampFormat: "2006/01/02 15:04:05",
        LogFormat:       "%time% [%lvl%] %msg% \n",
    })

    alwaysLoggingDeciderClient := func(ctx context.Context, fullMethodName string) bool { return true }
    grpc_logrus.ReplaceGrpcLogger(logrus.NewEntry(logger))

    p.gRPCLoggingOptions = append(
        p.gRPCLoggingOptions, option.WithGRPCDialOption(grpc.WithUnaryInterceptor(
            grpc_logrus.PayloadUnaryClientInterceptor(logrus.NewEntry(logger), alwaysLoggingDeciderClient))),
        option.WithGRPCDialOption(grpc.WithStreamInterceptor(
            grpc_logrus.PayloadStreamClientInterceptor(logrus.NewEntry(logger), alwaysLoggingDeciderClient))),
    )

    // Handle Batching Config
    batchingConfig := GetBatchingConfig(ctx, data.Batching, &resp.Diagnostics)
    if resp.Diagnostics.HasError() {
        return
    }

    p.context = ctx
    p.region = data.Region.String()
    p.pollInterval = 10 * time.Second
    p.requestBatcherServiceUsage = NewRequestBatcher("Service Usage", ctx, batchingConfig)
    p.requestBatcherIam = NewRequestBatcher("IAM", ctx, batchingConfig)

    // Example client configuration for data sources and resources
    resp.DataSourceData = p.client
    resp.ResourceData = p.client
}


// DataSources defines the data sources implemented in the provider.
func (p *frameworkProvider) DataSources(_ context.Context) []func() datasource.DataSource {
    return nil
}

// Resources defines the resources implemented in the provider.
func (p *frameworkProvider) Resources(_ context.Context) []func() resource.Resource {
    return nil
}
