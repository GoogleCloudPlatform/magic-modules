<% autogen_exception -%>
package google

import (
	"encoding/json"
	"fmt"
	"regexp"
	"sort"
	"strconv"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"google.golang.org/api/cloudresourcemanager/v1"
)

// dataSourceGoogleIamPolicy returns a *schema.Resource that allows a customer
// to express a Google Cloud IAM policy in a data resource. This is an example
// of how the schema would be used in a config:
//
// data "google_iam_policy" "admin" {
//   binding {
//     role = "roles/storage.objectViewer"
//     members = [
//       "user:evanbrown@google.com",
//     ]
//   }
// }
func dataSourceGoogleIamPolicy() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceGoogleIamPolicyRead,
		Schema: map[string]*schema.Schema{
			"binding": {
				Type: schema.TypeSet,
				// Binding is optional because a user may want to set an IAM policy with no bindings
				// This allows users to ensure that no bindings were created outside of terraform
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"role": {
							Type:     schema.TypeString,
							Required: true,
						},
						"members": {
							Type:     schema.TypeSet,
							Required: true,
							Elem: &schema.Schema{
								Type:         schema.TypeString,
								ValidateFunc: validation.StringDoesNotMatch(regexp.MustCompile("^deleted:"), "Terraform does not support IAM policies for deleted principals"),
							},
							Set: schema.HashString,
						},
						"condition": {
							Type:     schema.TypeList,
							Optional: true,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"expression": {
										Type:     schema.TypeString,
										Required: true,
									},
									"title": {
										Type:     schema.TypeString,
										Required: true,
									},
									"description": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},
			"policy_data": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"audit_config": {
				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"service": {
							Type:     schema.TypeString,
							Required: true,
						},
						"audit_log_configs": {
							Type:     schema.TypeSet,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"log_type": {
										Type:     schema.TypeString,
										Required: true,
									},
									"exempted_members": {
										Type:     schema.TypeSet,
										Elem:     &schema.Schema{Type: schema.TypeString},
										Optional: true,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// dataSourceGoogleIamPolicyRead reads a data source from config and writes it
// to state.
func dataSourceGoogleIamPolicyRead(d *schema.ResourceData, meta interface{}) error {
	var policy cloudresourcemanager.Policy
	var bindings []*cloudresourcemanager.Binding

	// The schema supports multiple binding{} blocks
	bset := d.Get("binding").(*schema.Set)
	aset := d.Get("audit_config").(*schema.Set)

	// All binding{} blocks will be converted and stored in an array
	bindings = make([]*cloudresourcemanager.Binding, bset.Len())

	// Convert each config binding into a cloudresourcemanager.Binding
	for i, v := range bset.List() {
		binding := v.(map[string]interface{})
		members := convertStringSet(binding["members"].(*schema.Set))
		condition := expandIamCondition(binding["condition"])

		bindings[i] = &cloudresourcemanager.Binding{
			Role:      binding["role"].(string),
			Members:   members,
			Condition: condition,
		}
	}

	// TODO(SarahFrench) improve comments
	// Collect bindings by combination of role + condition presence + condition expression combinations
	foundCombos := map[string]*cloudresourcemanager.Binding{}
	for _, v := range bindings {
		v := v // Avoid reused iteration variables
		id := v.Role
		if v.Condition != nil {
			id += fmt.Sprintf("-[%s]-[%s]-[%s]-[%s]", v.Condition.Expression, v.Condition.Title, v.Condition.Description, v.Condition.Location)
		}
		if val, ok := foundCombos[id]; ok {
			m := append(val.Members, v.Members...)
			binding := foundCombos[id]
			binding.Members = m
			foundCombos[id] = binding
		} else {
			foundCombos[id] = v
		}
	}

	// Assign deduplicated bindings to the cloudresourcemanager.Policy variable
	dedupBindings := []*cloudresourcemanager.Binding{}
	for _, v := range foundCombos {
		v := v // Avoid reused iteration variables
		dedupBindings = append(dedupBindings, v)
	}
	policy.Bindings = dedupBindings

	// Sort bindings to get simpler diffs as it's what the API does
	sort.Slice(policy.Bindings, func(i, j int) bool {
		// Sort bindings by role
		if policy.Bindings[i].Role < policy.Bindings[j].Role {
			return true
		}

		iConditionOk := policy.Bindings[i].Condition != nil
		jConditionOk := policy.Bindings[j].Condition != nil

		// If both bindings lack conditions we cannot sort
		if !iConditionOk && !jConditionOk {
			return false
		}

		// Sort by presence of a condition on only one binding
		if !iConditionOk && jConditionOk {
			return true
		}
		if iConditionOk && !jConditionOk {
			return false
		}

		// Sort by both bindings' conditions' titles
		if policy.Bindings[i].Condition.Title < policy.Bindings[j].Condition.Title {
			return true
		}

		// Sort by both bindings' conditions' expressions
		return policy.Bindings[i].Condition.Expression < policy.Bindings[j].Condition.Expression
	})

	// Sort members within each binding to get simpler diffs as it's what the API does
	for i := 0; i < len(policy.Bindings); i++ {
		sort.Strings(policy.Bindings[i].Members)
	}

	// Convert each audit_config into a cloudresourcemanager.AuditConfig
	policy.AuditConfigs = expandAuditConfig(aset)

	// Marshal cloudresourcemanager.Policy to JSON suitable for storing in state
	pjson, err := json.Marshal(&policy)
	if err != nil {
		// should never happen if the above code is correct
		return err
	}
	pstring := string(pjson)

	if err := d.Set("policy_data", pstring); err != nil {
		return fmt.Errorf("Error setting policy_data: %s", err)
	}
	d.SetId(strconv.Itoa(hashcode(pstring)))

	return nil
}

func expandAuditConfig(set *schema.Set) []*cloudresourcemanager.AuditConfig {
	auditConfigs := make([]*cloudresourcemanager.AuditConfig, 0, set.Len())
	for _, v := range set.List() {
		config := v.(map[string]interface{})
		// build list of audit configs first
		auditLogConfigSet := config["audit_log_configs"].(*schema.Set)
		// the array we're going to add to the outgoing resource
		auditLogConfigs := make([]*cloudresourcemanager.AuditLogConfig, 0, auditLogConfigSet.Len())
		for _, y := range auditLogConfigSet.List() {
			logConfig := y.(map[string]interface{})
			auditLogConfigs = append(auditLogConfigs, &cloudresourcemanager.AuditLogConfig{
				LogType:         logConfig["log_type"].(string),
				ExemptedMembers: convertStringArr(logConfig["exempted_members"].(*schema.Set).List()),
			})
		}
		auditConfigs = append(auditConfigs, &cloudresourcemanager.AuditConfig{
			Service:         config["service"].(string),
			AuditLogConfigs: auditLogConfigs,
		})
	}
	return auditConfigs
}
