<% autogen_exception -%>
package compute

import (
	"fmt"
	// TODO(felipegc) - remove log
	"log"

	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/errwrap"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
<% unless version == 'ga' -%>
	// TODO(felipegc)
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
<% end -%>

<% if version == "ga" -%>
	"google.golang.org/api/compute/v1"
<% else -%>
	compute "google.golang.org/api/compute/v0.beta"
<% end -%>
)

func computeInstanceDeleteAccessConfigs(d *schema.ResourceData, config *transport_tpg.Config, instNetworkInterface *compute.NetworkInterface, project, zone, userAgent, instanceName string) error {
	// Delete any accessConfig that currently exists in instNetworkInterface
	for _, ac := range instNetworkInterface.AccessConfigs {
		op, err := config.NewComputeClient(userAgent).Instances.DeleteAccessConfig(
			project, zone, instanceName, ac.Name, instNetworkInterface.Name).Do()
		if err != nil {
			return fmt.Errorf("Error deleting old access_config: %s", err)
		}
		opErr := ComputeOperationWaitTime(config, op, project, "old access_config to delete", userAgent, d.Timeout(schema.TimeoutUpdate))
		if opErr != nil {
			return opErr
		}
	}
	return nil
}

func computeInstanceAddAccessConfigs(d *schema.ResourceData, config *transport_tpg.Config, instNetworkInterface *compute.NetworkInterface, accessConfigs []*compute.AccessConfig, project, zone, userAgent, instanceName string) error {
	// Create new ones
	for _, ac := range accessConfigs {
		op, err := config.NewComputeClient(userAgent).Instances.AddAccessConfig(project, zone, instanceName, instNetworkInterface.Name, ac).Do()
		if err != nil {
			return fmt.Errorf("Error adding new access_config: %s", err)
		}
		opErr := ComputeOperationWaitTime(config, op, project, "new access_config to add", userAgent, d.Timeout(schema.TimeoutUpdate))
		if opErr != nil {
			return opErr
		}
	}
	return nil
}

func computeInstanceCreateUpdateWhileStoppedCall(d *schema.ResourceData, config *transport_tpg.Config, networkInterfacePatchObj *compute.NetworkInterface, accessConfigs []*compute.AccessConfig, accessConfigsHaveChanged bool, index int, project, zone, userAgent, instanceName string) func(inst *compute.Instance) error {

	// Access configs' ip changes when the instance stops invalidating our fingerprint
	// expect caller to re-validate instance before calling patch this is why we expect
	// instance to be passed in
	return func(instance *compute.Instance) error {

		instNetworkInterface := instance.NetworkInterfaces[index]
		networkInterfacePatchObj.Fingerprint = instNetworkInterface.Fingerprint

		// Access config can run into some issues since we can't tell the difference between
		// the users declared intent (config within their hcl file) and what we have inferred from the
		// server (terraform state). Access configs contain an ip subproperty that can be incompatible
		// with the subnetwork/network we are transitioning to. Due to this we only change access
		// configs if we notice the configuration (user intent) changes.
		if accessConfigsHaveChanged {
			err := computeInstanceDeleteAccessConfigs(d, config, instNetworkInterface, project, zone, userAgent, instanceName)
			if err != nil {
				return err
			}
		}

		op, err := config.NewComputeClient(userAgent).Instances.UpdateNetworkInterface(project, zone, instanceName, instNetworkInterface.Name, networkInterfacePatchObj).Do()
		if err != nil {
			return errwrap.Wrapf("Error updating network interface: {{err}}", err)
		}
		opErr := ComputeOperationWaitTime(config, op, project, "network interface to update", userAgent, d.Timeout(schema.TimeoutUpdate))
		if opErr != nil {
			return opErr
		}

		if accessConfigsHaveChanged {
			err := computeInstanceAddAccessConfigs(d, config, instNetworkInterface, accessConfigs, project, zone, userAgent, instanceName)
			if err != nil {
				return err
			}
		}
		return nil
	}
}

<% unless version == 'ga' -%>
func computeInstanceAddSecurityPolicy(d *schema.ResourceData, config *transport_tpg.Config, securityPolicyWithNics map[string][]string, project, zone, userAgent, instanceName string) error {
	for sp, nics := range securityPolicyWithNics {
		req := &compute.InstancesSetSecurityPolicyRequest{
			NetworkInterfaces: nics,
			SecurityPolicy:    sp,
		}
		op, err := config.NewComputeClient(userAgent).Instances.SetSecurityPolicy(project, zone, instanceName, req).Do()
		if err != nil {
			return fmt.Errorf("Error adding security policy: %s", err)
		}
		opErr := ComputeOperationWaitTime(config, op, project, "security_policy to add", userAgent, d.Timeout(schema.TimeoutUpdate))
		if opErr != nil {
			return opErr
		}
	}

	return nil
}

func computeInstanceMapSecurityPoliciesForCreate(instance *compute.Instance) map[string][]string {
	securityPolicies := make(map[string][]string)
	for i := 0; i < len(instance.NetworkInterfaces); i++ {
		ni := instance.NetworkInterfaces[i]
		// Network interfaces use the nicN naming format and is only know after the instance is created.
		nicName := fmt.Sprintf("nic%d", i)

		for j := 0; j < len(ni.AccessConfigs); j++ {
			log.Printf("[DEBUG] FELIPEGC OLHA A NETWORKINTERFACE[i].AccessConfig[j] SECURITY POLICY %#v", instance.NetworkInterfaces[i].AccessConfigs[j].SecurityPolicy)
			ac := ni.AccessConfigs[j]
			// Is not necessary to map empty security policy during the instance creation.
			if ac.SecurityPolicy != "" {
				securityPolicies[ac.SecurityPolicy] = append(securityPolicies[ac.SecurityPolicy], nicName)
			}
		}
	}
	log.Printf("[DEBUG] FELIPEGC OLHA O MAP DE SEC_POLICY X INTERFACE: %#v", securityPolicies)

	return securityPolicies
}

func computeInstanceMapSecurityPoliciesForCreate2(d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string][]string, error) {
	configs := d.Get("network_interface").([]interface{})
	securityPolicies := make(map[string][]string)
	for i, raw := range configs {
		data := raw.(map[string]interface{})
		ac := expandAccessConfigs(data["access_config"].([]interface{}))
		ipv6Ac := expandIpv6AccessConfigs(data["ipv6_access_config"].([]interface{}))
		secPolicy := data["security_policy"].(string)

		if secPolicy != "" && len(ac) == 0 && len(ipv6Ac) == 0 {
			return securityPolicies, fmt.Errorf("At least one access config must exist to set the security policy")
		}

		if secPolicy != "" {
			nicName := fmt.Sprintf("nic%d", i)
			securityPolicies[secPolicy] = append(securityPolicies[secPolicy], nicName)
		}
	}
	log.Printf("[DEBUG] FELIPEGC OLHA O MAP DE SEC_POLICY X INTERFACE: %#v", securityPolicies)

	return securityPolicies, nil
}

// TODO(felipegc)
func computeInstanceMapSecurityPoliciesForCreate3(d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string][]string, error) {
	securityPolicies := make(map[string][]string)
	configs := d.Get("network_interface").([]interface{})
	for i, raw := range configs {
		data := raw.(map[string]interface{})
		acessConfigs := expandAccessConfigs(data["access_config"].([]interface{}))
		ipv6AccessConfigs := expandIpv6AccessConfigs(data["ipv6_access_config"].([]interface{}))

		// Network interfaces use the nicN naming format and is only know after the instance is created.
		nicName := fmt.Sprintf("nic%d", i)
		// The security_policy must be unique through all the accessConfigs and ipv6AccessConfigs under the same networkInterface.
		uniqueSecPolicy := ""

		for j := 0; j < len(acessConfigs); j++ {
			log.Printf("[DEBUG] FELIPEGC OLHA A NETWORKINTERFACE[i].AccessConfig[j] SECURITY POLICY %#v", acessConfigs[j].SecurityPolicy)
			ac := acessConfigs[j]

			if uniqueSecPolicy != "" && ac.SecurityPolicy != uniqueSecPolicy {
				log.Printf("[DEBUG] FELIPEGC ACCESS CONFIG SOU DIFERENTE: %s ---> %s", ac.SecurityPolicy, uniqueSecPolicy)
				return securityPolicies, fmt.Errorf("Error to create security policy to the instance, all the security policies must be equal through all access configs for the same network interface")
			}

			securityPolicies[ac.SecurityPolicy] = append(securityPolicies[ac.SecurityPolicy], nicName)
			uniqueSecPolicy = ac.SecurityPolicy
		}

		for j := 0; j < len(ipv6AccessConfigs); j++ {
			log.Printf("[DEBUG] FELIPEGC OLHA A NETWORKINTERFACE[i].Ipv6AccessConfig[j] SECURITY POLICY %#v", ipv6AccessConfigs[j].SecurityPolicy)
			ip6ac := ipv6AccessConfigs[j]
			// Is not necessary to map empty security policy during the instance creation.

			if uniqueSecPolicy != "" && ip6ac.SecurityPolicy != uniqueSecPolicy {
				log.Printf("[DEBUG] FELIPEGC IPV6 ACCESS CONFIG SOU DIFERENTE: %s ---> %s", ip6ac.SecurityPolicy, uniqueSecPolicy)
				return securityPolicies, fmt.Errorf("Error to create security policy to the instance, all the security policies must be equal through all access configs for the same network interface")
			}

			securityPolicies[ip6ac.SecurityPolicy] = append(securityPolicies[ip6ac.SecurityPolicy], nicName)
			uniqueSecPolicy = ip6ac.SecurityPolicy
		}
	}
	log.Printf("[DEBUG] FELIPEGC OLHA O MAP DE SEC_POLICY X INTERFACE: %#v", securityPolicies)

	return securityPolicies, nil
}

func computeInstanceMapSecurityPoliciesForUpdate(instance *compute.Instance, d *schema.ResourceData) (map[string][]string, error) {
	securityPolicies := make(map[string][]string)
	for i := 0; i < len(instance.NetworkInterfaces); i++ {
		prefix := fmt.Sprintf("network_interface.%d", i)
		if d.HasChange(prefix + ".access_config") {
			o, n := d.GetChange(prefix + ".access_config")
			log.Printf("[DEBUG] FELIPEGC OLHA O STATE DA INSTANCIA: %#v", instance.Status)
			old := expandAccessConfigs(o.([]interface{}))
			new := expandAccessConfigs(n.([]interface{}))
			log.Printf("[DEBUG] FELIPEGC OLHA O ACCESS CONFIG OLD CONVERTIDO: %#v", old)
			log.Printf("[DEBUG] FELIPEGC OLHA O ACCESS CONFIG NOVO CONVERTIDO: %#v", new)

			// Right now there is a GCE limit of 1 accessConfig.
			securityPolicyHasReplaced := len(new) > 0 && len(old) > 0 && new[0].SecurityPolicy != old[0].SecurityPolicy
			securityPolicyHasAdded := len(new) > 0 && len(old) == 0 && new[0].SecurityPolicy != ""
			securityPolicyHasChanged := securityPolicyHasReplaced || securityPolicyHasAdded
			log.Printf("[DEBUG] FELIPEGC OLHA O ACCESS CONFIG SEC POLICY HAS CHANGED: %#v", securityPolicyHasChanged)
			if securityPolicyHasChanged && instance.Status != "RUNNING" {
				log.Print("[DEBUG] FELIPEGC LANCA EXCEPTION PQ PRECISA ESTA RODANDO")
				return securityPolicies, fmt.Errorf("Error to update security policy to the instance, the current status must be \"RUNNING\"")
			}

			// Security policy can only exist if access config is present.
			if len(new) > 0 {
				securityPolicies[new[0].SecurityPolicy] = append(securityPolicies[new[0].SecurityPolicy], instance.NetworkInterfaces[i].Name)
			}
		}
	}
	log.Printf("[DEBUG] FELIPEGC OLHA O MAP DE SEC_POLICY X INTERFACE: %#v", securityPolicies)

	return securityPolicies, nil
}

<% end -%>