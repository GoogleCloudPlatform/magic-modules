package container

import (
{{ if ne $.TargetVersionName `ga` -}}
	"strings"
{{- end }}
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"

{{ if eq $.TargetVersionName `ga` }}
	"google.golang.org/api/container/v1"
{{- else }}
	container "google.golang.org/api/container/v1beta1"
{{- end }}
)

{{ if ne $.TargetVersionName `ga` -}}
func TestValidateNodePoolAutoConfig(t *testing.T) {
	withTags := &container.NodePoolAutoConfig{
		NetworkTags: &container.NetworkTags{
			Tags: []string{"not-empty"},
		},
	}
	noTags := &container.NodePoolAutoConfig{}

	cases := map[string]struct {
		Input       *container.Cluster
		ExpectError bool
	}{
		"with tags, nap nil, autopilot nil": {
			Input:       &container.Cluster{NodePoolAutoConfig: withTags},
			ExpectError: true,
		},
		"with tags, autopilot disabled": {
			Input: &container.Cluster{
				Autopilot:          &container.Autopilot{Enabled: false},
				NodePoolAutoConfig: withTags,
			},
			ExpectError: true,
		},
		"with tags, nap disabled": {
			Input: &container.Cluster{
				Autoscaling:        &container.ClusterAutoscaling{EnableNodeAutoprovisioning: false},
				NodePoolAutoConfig: withTags,
			},
			ExpectError: true,
		},
		"with tags, autopilot enabled": {
			Input: &container.Cluster{
				Autopilot:          &container.Autopilot{Enabled: true},
				NodePoolAutoConfig: withTags,
			},
			ExpectError: false,
		},
		"with tags, nap enabled": {
			Input: &container.Cluster{
				Autoscaling:        &container.ClusterAutoscaling{EnableNodeAutoprovisioning: true},
				NodePoolAutoConfig: withTags,
			},
			ExpectError: false,
		},
		"no tags, autopilot enabled": {
			Input: &container.Cluster{
				Autopilot:          &container.Autopilot{Enabled: true},
				NodePoolAutoConfig: noTags,
			},
			ExpectError: false,
		},
		"no tags, nap enabled": {
			Input: &container.Cluster{
				Autoscaling:        &container.ClusterAutoscaling{EnableNodeAutoprovisioning: true},
				NodePoolAutoConfig: noTags,
			},
			ExpectError: false,
		},
		"no tags, autopilot disabled": {
			Input: &container.Cluster{
				Autopilot:          &container.Autopilot{Enabled: false},
				NodePoolAutoConfig: noTags,
			},
			ExpectError: false,
		},
		"no tags, nap disabled": {
			Input: &container.Cluster{
				Autoscaling:        &container.ClusterAutoscaling{EnableNodeAutoprovisioning: false},
				NodePoolAutoConfig: noTags,
			},
			ExpectError: false,
		},
	}

	for tn, tc := range cases {
		if err := validateNodePoolAutoConfig(tc.Input); (err != nil) != tc.ExpectError {
			t.Fatalf("bad: '%s', expected error: %t, received error: %t", tn, tc.ExpectError, (err != nil))
		}
	}
}

func TestSandboxTypeDiffSuppress(t *testing.T) {
	t.Parallel()

	cases := map[string]struct {
		fieldKey         string
		oldValue         string
		newValue         string
		sandboxTypeOld   interface{}
		sandboxTypeNew   interface{}
		typeOld          interface{}
		typeNew          interface{}
		expectedSuppress bool
	}{
		"sandbox_type field with type field set in config - should suppress": {
			fieldKey:         "node_config.0.sandbox_config.0.sandbox_type",
			oldValue:         "",
			newValue:         "gvisor",
			sandboxTypeOld:   nil,
			sandboxTypeNew:   "gvisor",
			typeOld:          nil,
			typeNew:          "GVISOR",
			expectedSuppress: true,
		},
		"type field with sandbox_type field set in config - should suppress": {
			fieldKey:         "node_config.0.sandbox_config.0.type",
			oldValue:         "",
			newValue:         "GVISOR",
			sandboxTypeOld:   nil,
			sandboxTypeNew:   "gvisor",
			typeOld:          nil,
			typeNew:          "GVISOR",
			expectedSuppress: true,
		},
		"sandbox_type field with no other field set - should not suppress": {
			fieldKey:         "node_config.0.sandbox_config.0.sandbox_type",
			oldValue:         "",
			newValue:         "gvisor",
			sandboxTypeOld:   nil,
			sandboxTypeNew:   "gvisor",
			typeOld:          nil,
			typeNew:          nil,
			expectedSuppress: false,
		},
		"type field with no other field set - should not suppress": {
			fieldKey:         "node_config.0.sandbox_config.0.type",
			oldValue:         "",
			newValue:         "GVISOR",
			sandboxTypeOld:   nil,
			sandboxTypeNew:   nil,
			typeOld:          nil,
			typeNew:          "GVISOR",
			expectedSuppress: false,
		},
		"sandbox_type field with empty type field - should not suppress": {
			fieldKey:         "node_config.0.sandbox_config.0.sandbox_type",
			oldValue:         "",
			newValue:         "gvisor",
			sandboxTypeOld:   nil,
			sandboxTypeNew:   "gvisor",
			typeOld:          nil,
			typeNew:          "",
			expectedSuppress: false,
		},
		"type field with empty sandbox_type field - should not suppress": {
			fieldKey:         "node_config.0.sandbox_config.0.type",
			oldValue:         "",
			newValue:         "GVISOR",
			sandboxTypeOld:   nil,
			sandboxTypeNew:   "",
			typeOld:          nil,
			typeNew:          "GVISOR",
			expectedSuppress: false,
		},
		"nested path - cluster node_pool sandbox_type with type set - should suppress": {
			fieldKey:         "node_pool.0.node_config.0.sandbox_config.0.sandbox_type",
			oldValue:         "",
			newValue:         "gvisor",
			sandboxTypeOld:   nil,
			sandboxTypeNew:   "gvisor",
			typeOld:          nil,
			typeNew:          "GVISOR",
			expectedSuppress: true,
		},
		"nested path - cluster node_pool type with sandbox_type set - should suppress": {
			fieldKey:         "node_pool.0.node_config.0.sandbox_config.0.type",
			oldValue:         "",
			newValue:         "GVISOR",
			sandboxTypeOld:   nil,
			sandboxTypeNew:   "gvisor",
			typeOld:          nil,
			typeNew:          "GVISOR",
			expectedSuppress: true,
		},
		"non-sandbox field - should not suppress": {
			fieldKey:         "node_config.0.other_field",
			oldValue:         "",
			newValue:         "value",
			sandboxTypeOld:   nil,
			sandboxTypeNew:   nil,
			typeOld:          nil,
			typeNew:          nil,
			expectedSuppress: false,
		},
	}

	for tn, tc := range cases {
		t.Run(tn, func(t *testing.T) {
			before := make(map[string]interface{})
			after := make(map[string]interface{})

			var sandboxTypeKey, typeKey string
			if strings.Contains(tc.fieldKey, "sandbox_type") {
				root := strings.TrimSuffix(tc.fieldKey, "sandbox_type")
				root = strings.TrimSuffix(root, ".")
				sandboxTypeKey = root + ".sandbox_type"
				typeKey = root + ".type"
			} else if strings.Contains(tc.fieldKey, ".type") {
				root := strings.TrimSuffix(tc.fieldKey, "type")
				root = strings.TrimSuffix(root, ".")
				sandboxTypeKey = root + ".sandbox_type"
				typeKey = root + ".type"
			}

			if sandboxTypeKey != "" {
				before[sandboxTypeKey] = tc.sandboxTypeOld
				after[sandboxTypeKey] = tc.sandboxTypeNew
			}
			if typeKey != "" {
				before[typeKey] = tc.typeOld
				after[typeKey] = tc.typeNew
			}

			d := &tpgresource.ResourceDiffMock{
				Before: before,
				After:  after,
			}

			result := SandboxTypeDiffSuppress(tc.fieldKey, tc.oldValue, tc.newValue, d)
			if result != tc.expectedSuppress {
				t.Errorf("%s: expected suppress to be %v, but was %v", tn, tc.expectedSuppress, result)
			}
		})
	}
}
{{- end }}


func TestContainerClusterEnableK8sBetaApisCustomizeDiff(t *testing.T) {
	t.Parallel()

	cases := map[string]struct {
		before           *schema.Set
		after            *schema.Set
		expectedForceNew bool
	}{
		"no need to force new from nil to empty apis": {
			before:           schema.NewSet(schema.HashString, nil),
			after:            schema.NewSet(schema.HashString, []interface{}{}),
			expectedForceNew: false,
		},
		"no need to force new from empty apis to nil": {
			before:           schema.NewSet(schema.HashString, []interface{}{}),
			after:            schema.NewSet(schema.HashString, nil),
			expectedForceNew: false,
		},
		"no need to force new from empty apis to empty apis": {
			before:           schema.NewSet(schema.HashString, []interface{}{}),
			after:            schema.NewSet(schema.HashString, []interface{}{}),
			expectedForceNew: false,
		},
		"no need to force new from nil to empty string apis": {
			before:           schema.NewSet(schema.HashString, nil),
			after:            schema.NewSet(schema.HashString, []interface{}{""}),
			expectedForceNew: false,
		},
		"no need to force new from empty string apis to empty string apis": {
			before:           schema.NewSet(schema.HashString, []interface{}{""}),
			after:            schema.NewSet(schema.HashString, []interface{}{""}),
			expectedForceNew: false,
		},
		"no need to force new for enabling new api from empty apis": {
			before:           schema.NewSet(schema.HashString, []interface{}{}),
			after:            schema.NewSet(schema.HashString, []interface{}{"dummy.k8s.io/v1beta1/foo"}),
			expectedForceNew: false,
		},
		"no need to force new for enabling new api from nil": {
			before:           schema.NewSet(schema.HashString, nil),
			after:            schema.NewSet(schema.HashString, []interface{}{"dummy.k8s.io/v1beta1/foo"}),
			expectedForceNew: false,
		},
		"no need to force new for passing same apis": {
			before:           schema.NewSet(schema.HashString, []interface{}{"dummy.k8s.io/v1beta1/foo"}),
			after:            schema.NewSet(schema.HashString, []interface{}{"dummy.k8s.io/v1beta1/foo"}),
			expectedForceNew: false,
		},
		"no need to force new for passing same apis with inconsistent order": {
			before:           schema.NewSet(schema.HashString, []interface{}{"dummy.k8s.io/v1beta1/foo", "dummy.k8s.io/v1beta1/bar"}),
			after:            schema.NewSet(schema.HashString, []interface{}{"dummy.k8s.io/v1beta1/bar", "dummy.k8s.io/v1beta1/foo"}),
			expectedForceNew: false,
		},
		"need to force new from empty string apis to nil": {
			before:           schema.NewSet(schema.HashString, []interface{}{""}),
			after:            schema.NewSet(schema.HashString, nil),
			expectedForceNew: true,
		},
		"need to force new for disabling existing api": {
			before:           schema.NewSet(schema.HashString, []interface{}{"dummy.k8s.io/v1beta1/foo"}),
			after:            schema.NewSet(schema.HashString, []interface{}{}),
			expectedForceNew: true,
		},
		"need to force new for disabling existing api with nil": {
			before:           schema.NewSet(schema.HashString, []interface{}{"dummy.k8s.io/v1beta1/foo"}),
			after:            schema.NewSet(schema.HashString, nil),
			expectedForceNew: true,
		},
		"need to force new for disabling existing apis": {
			before:           schema.NewSet(schema.HashString, []interface{}{"dummy.k8s.io/v1beta1/foo", "dummy.k8s.io/v1beta1/bar", "dummy.k8s.io/v1beta1/baz"}),
			after:            schema.NewSet(schema.HashString, []interface{}{"dummy.k8s.io/v1beta1/foo"}),
			expectedForceNew: true,
		},
	}

	for tn, tc := range cases {
		d := &tpgresource.ResourceDiffMock{
			Before: map[string]interface{}{
				"enable_k8s_beta_apis.0.enabled_apis": tc.before,
			},
			After: map[string]interface{}{
				"enable_k8s_beta_apis.0.enabled_apis": tc.after,
			},
		}
		err := containerClusterEnableK8sBetaApisCustomizeDiffFunc(d)
		if err != nil {
			t.Errorf("%s failed, found unexpected error: %s", tn, err)
		}
		if d.IsForceNew != tc.expectedForceNew {
			t.Errorf("%v: expected d.IsForceNew to be %v, but was %v", tn, tc.expectedForceNew, d.IsForceNew)
		}
	}
}

func TestContainerCluster_NodeVersionCustomizeDiff(t* testing.T) {
	t.Parallel()

	cases := map[string]struct{
		BeforeName string 
		AfterName string
		MasterVersion  string
		NodeVersion  string
		ExpectError  bool
	}{
		"Master version and node version are exactly the same" : {
			BeforeName : "",
			AfterName : "test",
			MasterVersion : "1.10.9-gke.5",
			NodeVersion : "1.10.9-gke.5",
			ExpectError : false,
		},
		"Master version and node version have the same Kubernetes patch version but not the same gke-N suffix " : {
			BeforeName : "",
			AfterName : "test",
			MasterVersion : "1.10.9-gke.5",
			NodeVersion : "1.10.9-gke.9",
			ExpectError : false,
		},
		"Master version and node version have different minor versions" :{
			BeforeName : "",
			AfterName : "test",
			MasterVersion : "1.10.9-gke.5",
			NodeVersion : "1.11.6-gke.11",
			ExpectError : true,
		},
		"Master version and node version have different Kubernetes Patch Versions" :{
			BeforeName : "",
			AfterName : "test",
			MasterVersion : "1.10.9-gke.5",
			NodeVersion : "1.10.6-gke.11",
			ExpectError : true,
		},
		"Master version is not set, but node version is" : {
			BeforeName : "",
			AfterName : "test",
			MasterVersion : "",
			NodeVersion : "1.10.6-gke.11",
			ExpectError : false,
		},
		"Node version is not set, but master version is" : {
			BeforeName : "",
			AfterName : "test",
			MasterVersion : "1.10.6-gke.11",
			NodeVersion : "",
			ExpectError : false,
		},
		"Node version and master version match, both do not have -gke.X suffix" :{
			BeforeName : "",
			AfterName : "test",
			MasterVersion : "1.10.6",
			NodeVersion : "1.10.6",
			ExpectError : false,

		},
		"Node version and master version do not match, both do not have -gke.X suffix" : {
			BeforeName : "",
			AfterName : "test",
			MasterVersion : "1.10.6",
			NodeVersion : "1.11.6",
			ExpectError : true,

		},
		"Node version and master version do not match, node version has -gke.X suffix but master version doesn't" : {
			BeforeName : "",
			AfterName : "test",
			MasterVersion : "1.11.6",
			NodeVersion : "1.10.6-gke.11",
			ExpectError : true,
		},
		"Diff is executed in non-create scenario, master version and node version do not match" : {
			BeforeName : "test",
			AfterName : "test-1",
			MasterVersion : "1.11.6-gke.11",
			NodeVersion : "1.10.6-gke.11",
			ExpectError : false,
		},
	}

	for tn,tc := range cases {
		d := &tpgresource.ResourceDiffMock{
			Before: map[string]interface{}{
				"name" : tc.BeforeName,
				"min_master_version": "",
				"node_version": "",
			},
			After: map[string]interface{}{
				"name" : tc.AfterName,
				"min_master_version": tc.MasterVersion,
				"node_version": tc.NodeVersion,
			},
		}
		err := containerClusterNodeVersionCustomizeDiffFunc(d)

		if tc.ExpectError && err == nil {
			t.Errorf("%s failed, expected error but was none", tn)
		}
		if !tc.ExpectError && err != nil {
			t.Errorf("%s failed, found unexpected error: %s", tn, err)
		}
	}
}

func TestContainerCluster_flattenUserManagedKeysConfig(t *testing.T) {
	t.Parallel()

	cases := []struct {
		name   string
		config *container.UserManagedKeysConfig
		want   []map[string]interface{}
	}{
		{
			name: "nil",
		},
		{
			name:   "empty",
			config: &container.UserManagedKeysConfig{},
		},
		{
			name: "cluster_ca",
			config: &container.UserManagedKeysConfig{
				ClusterCa: "value",
			},
			want: []map[string]interface{}{
				{
					"cluster_ca":                        "value",
					"etcd_api_ca":                       "",
					"etcd_peer_ca":                      "",
					"aggregation_ca":                    "",
					"control_plane_disk_encryption_key": "",
					"gkeops_etcd_backup_encryption_key": "",
				},
			},
		},
		{
			name: "etcd_api_ca",
			config: &container.UserManagedKeysConfig{
				EtcdApiCa: "value",
			},
			want: []map[string]interface{}{
				{
					"cluster_ca":                        "",
					"etcd_api_ca":                       "value",
					"etcd_peer_ca":                      "",
					"aggregation_ca":                    "",
					"control_plane_disk_encryption_key": "",
					"gkeops_etcd_backup_encryption_key": "",
				},
			},
		},
		{
			name: "etcd_peer_ca",
			config: &container.UserManagedKeysConfig{
				EtcdPeerCa: "value",
			},
			want: []map[string]interface{}{
				{
					"cluster_ca":                        "",
					"etcd_api_ca":                       "",
					"etcd_peer_ca":                      "value",
					"aggregation_ca":                    "",
					"control_plane_disk_encryption_key": "",
					"gkeops_etcd_backup_encryption_key": "",
				},
			},
		},
		{
			name: "aggregation_ca",
			config: &container.UserManagedKeysConfig{
				AggregationCa: "value",
			},
			want: []map[string]interface{}{
				{
					"cluster_ca":                        "",
					"etcd_api_ca":                       "",
					"etcd_peer_ca":                      "",
					"aggregation_ca":                    "value",
					"control_plane_disk_encryption_key": "",
					"gkeops_etcd_backup_encryption_key": "",
				},
			},
		},
		{
			name: "control_plane_disk_encryption_key",
			config: &container.UserManagedKeysConfig{
				ControlPlaneDiskEncryptionKey: "value",
			},
			want: []map[string]interface{}{
				{
					"cluster_ca":                        "",
					"etcd_api_ca":                       "",
					"etcd_peer_ca":                      "",
					"aggregation_ca":                    "",
					"control_plane_disk_encryption_key": "value",
					"gkeops_etcd_backup_encryption_key": "",
				},
			},
		},
		{
			name: "gkeops_etcd_backup_encryption_key",
			config: &container.UserManagedKeysConfig{
				GkeopsEtcdBackupEncryptionKey: "value",
			},
			want: []map[string]interface{}{
				{
					"cluster_ca":                        "",
					"etcd_api_ca":                       "",
					"etcd_peer_ca":                      "",
					"aggregation_ca":                    "",
					"control_plane_disk_encryption_key": "",
					"gkeops_etcd_backup_encryption_key": "value",
				},
			},
		},
		{
			name: "service_account_signing_keys",
			config: &container.UserManagedKeysConfig{
				ServiceAccountSigningKeys: []string{"value"},
			},
			want: []map[string]interface{}{
				{
					"cluster_ca":                        "",
					"etcd_api_ca":                       "",
					"etcd_peer_ca":                      "",
					"aggregation_ca":                    "",
					"control_plane_disk_encryption_key": "",
					"gkeops_etcd_backup_encryption_key": "",
					"service_account_signing_keys":      schema.NewSet(schema.HashString, []interface{}{"value"}),
				},
			},
		},
		{
			name: "service_account_verification_keys",
			config: &container.UserManagedKeysConfig{
				ServiceAccountVerificationKeys: []string{"value"},
			},
			want: []map[string]interface{}{
				{
					"cluster_ca":                        "",
					"etcd_api_ca":                       "",
					"etcd_peer_ca":                      "",
					"aggregation_ca":                    "",
					"control_plane_disk_encryption_key": "",
					"gkeops_etcd_backup_encryption_key": "",
					"service_account_verification_keys": schema.NewSet(schema.HashString, []interface{}{"value"}),
				},
			},
		},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			got := flattenUserManagedKeysConfig(tc.config)
			if diff := cmp.Diff(got, tc.want); diff != "" {
				t.Errorf("flattenUserManagedKeysConfig(%s) returned unexpected diff. +got, -want:\n%s", tc.name, diff)
			}
		})
	}
}
