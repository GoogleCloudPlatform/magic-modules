package transport

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"time"
	"os"

	"cloud.google.com/go/auth/credentials"
	"cloud.google.com/go/auth/credentials/impersonate"
	"cloud.google.com/go/auth/oauth2adapt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"

	grpc_logrus "github.com/grpc-ecosystem/go-grpc-middleware/logging/logrus"

	"github.com/hashicorp/go-cleanhttp"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/sirupsen/logrus"
	"google.golang.org/api/option"
	"google.golang.org/api/option/internaloption"

	"github.com/hashicorp/terraform-provider-google/google/verify"

	"golang.org/x/oauth2"
	"google.golang.org/grpc"
	googleoauth "golang.org/x/oauth2/google"
	externalaccount "golang.org/x/oauth2/google/externalaccount"
	appengine "google.golang.org/api/appengine/v1"
	"google.golang.org/api/bigquery/v2"
	"google.golang.org/api/bigtableadmin/v2"
	"google.golang.org/api/certificatemanager/v1"
	"google.golang.org/api/cloudbilling/v1"
	"google.golang.org/api/cloudbuild/v1"
{{- if ne $.TargetVersionName "ga" }}
	cloudidentity "google.golang.org/api/cloudidentity/v1beta1"
{{- else }}
	"google.golang.org/api/cloudidentity/v1"
{{- end }}
	"google.golang.org/api/cloudfunctions/v1"
	"google.golang.org/api/cloudiot/v1"
	"google.golang.org/api/cloudkms/v1"
	"google.golang.org/api/cloudresourcemanager/v1"
	resourceManagerV3 "google.golang.org/api/cloudresourcemanager/v3"
{{- if eq $.TargetVersionName "ga" }}
	"google.golang.org/api/composer/v1"
{{- else }}
	"google.golang.org/api/composer/v1beta1"
{{- end }}
{{- if eq $.TargetVersionName "ga" }}
	"google.golang.org/api/compute/v1"
{{- else }}
	compute "google.golang.org/api/compute/v0.beta"
{{- end }}
{{- if eq $.TargetVersionName "ga" }}
	"google.golang.org/api/container/v1"
{{- else }}
	container "google.golang.org/api/container/v1beta1"
{{- end }}
	dataflow "google.golang.org/api/dataflow/v1b3"
	"google.golang.org/api/dataproc/v1"
	"google.golang.org/api/dns/v1"
{{- if ne $.TargetVersionName "ga" }}
	firebase "google.golang.org/api/firebase/v1beta1"
{{- end }}
	healthcare "google.golang.org/api/healthcare/v1"
	"google.golang.org/api/iam/v1"
	iamcredentials "google.golang.org/api/iamcredentials/v1"
	cloudlogging "google.golang.org/api/logging/v2"
	"google.golang.org/api/pubsub/v1"
	runadminv2 "google.golang.org/api/run/v2"
{{- if ne $.TargetVersionName "ga" }}
	runtimeconfig "google.golang.org/api/runtimeconfig/v1beta1"
{{- end }}
	"google.golang.org/api/servicemanagement/v1"
	"google.golang.org/api/servicenetworking/v1"
	"google.golang.org/api/serviceusage/v1"
	"google.golang.org/api/sourcerepo/v1"
	"google.golang.org/api/spanner/v1"
	sqladmin "google.golang.org/api/sqladmin/v1beta4"
	backupdr "google.golang.org/api/backupdr/v1"
	"google.golang.org/api/storage/v1"
	"google.golang.org/api/storagetransfer/v1"
	"google.golang.org/api/transport"
)

type ProviderMeta struct {
	ModuleName string `cty:"module_name"`
}

type Formatter struct {
	TimestampFormat string
	LogFormat string
}

// Borrowed logic from https://github.com/sirupsen/logrus/blob/master/json_formatter.go and https://github.com/t-tomalak/logrus-easy-formatter/blob/master/formatter.go
func (f *Formatter) Format(entry *logrus.Entry) ([]byte, error) {
	// Suppress logs if TF_LOG is not DEBUG or TRACE
	if !logging.IsDebugOrHigher() {
		return nil, nil
	}

	// Also suppress based on log content
	// - frequent transport spam
	// - ListenSocket logs from gRPC
	isTransportSpam := strings.Contains(entry.Message, "transport is closing")
	listenSocketRegex := regexp.MustCompile(`\[Server #\d+( ListenSocket #\d+)*\]`) // Match patterns like `[Server #00]` or `[Server #00 ListenSocket #00]`
	isListenSocketLog := listenSocketRegex.MatchString(entry.Message)
	if isTransportSpam || isListenSocketLog {
		return nil, nil
	}

	output := f.LogFormat
	entry.Level = logrus.DebugLevel // Force Entries to be Debug

	timestampFormat := f.TimestampFormat

	output = strings.Replace(output, "%time%", entry.Time.Format(timestampFormat), 1)

	output = strings.Replace(output, "%msg%", entry.Message, 1)

	level := strings.ToUpper(entry.Level.String())
	output = strings.Replace(output, "%lvl%", level, 1)

	var gRPCMessageFlag bool
	for k, val := range entry.Data {
		switch v := val.(type) {
		case string:
			output = strings.Replace(output, "%"+k+"%", v, 1)
		case int:
			s := strconv.Itoa(v)
			output = strings.Replace(output, "%"+k+"%", s, 1)
		case bool:
			s := strconv.FormatBool(v)
			output = strings.Replace(output, "%"+k+"%", s, 1)
		}

		if k != "system" {
			gRPCMessageFlag = true
		}
	}

	if gRPCMessageFlag {
		data := make(logrus.Fields, len(entry.Data)+4)
		for k, v := range entry.Data {
			switch v := v.(type) {
			case error:
				// Otherwise errors are ignored by `encoding/json`
				// https://github.com/sirupsen/logrus/issues/137
				data[k] = v.Error()
			default:
				data[k] = v
			}
		}

		var b *bytes.Buffer
		if entry.Buffer != nil {
			b = entry.Buffer
		} else {
			b = &bytes.Buffer{}
		}

		encoder := json.NewEncoder(b)
		encoder.SetIndent("", "  ")
		if err := encoder.Encode(data); err != nil {
			return nil, fmt.Errorf("failed to marshal fields to JSON, %w", err)
		}

		finalOutput := append([]byte(output), b.Bytes()...)
		return finalOutput, nil
	}

	return []byte(output), nil
}

type ExternalCredentials struct {
	Audience            string
	ServiceAccountEmail string
	IdentityToken    string
}

var _ externalaccount.SubjectTokenSupplier = ExternalCredentials{}

// SubjectToken returns the identity token passed to the provider as an argument from the config.
// We do not interact with an external system to get a token.
func (e ExternalCredentials) SubjectToken(ctx context.Context, options externalaccount.SupplierOptions) (string, error) {
	if e.IdentityToken != "" {
		return e.IdentityToken, nil
	}
	return "", errors.New("identity token unavailable in Config when configuring the provider")
}

func ExpandExternalCredentialsConfig(v interface{}) (*ExternalCredentials, error) {
	if v == nil {
		return nil, nil
	}
	ls := v.([]interface{})
	if len(ls) == 0 || ls[0] == nil {
		return nil, nil
	}

	config := &ExternalCredentials{}
	cfgV := ls[0].(map[string]interface{})

	audience, ok := cfgV["audience"]
	if !ok || audience.(string) == "" {
		return nil, errors.New("missing value for external_credentials.audience")
	}
	config.Audience = audience.(string)

	email, ok := cfgV["service_account_email"]
	if !ok || email.(string) == "" {
		return nil, errors.New("missing value for external_credentials.service_account_email")
	}
	config.ServiceAccountEmail = email.(string)

	jwt, ok := cfgV["identity_token"]
	if !ok || jwt.(string) == "" {
		return nil, errors.New("missing value for external_credentials.identity_token")
	}
	config.IdentityToken = jwt.(string)

	return config, nil
}

// Config is the configuration structure used to instantiate the Google
// provider.
type Config struct {
	AccessToken                               string
	Credentials                               string
	ExternalCredentials                       *ExternalCredentials
	ImpersonateServiceAccount                 string
	ImpersonateServiceAccountDelegates        []string
	Project                                   string
	Region                                    string
	BillingProject                            string
	Zone                                      string
	UniverseDomain                            string
	Scopes                                    []string
	BatchingConfig                            *BatchingConfig
	UserProjectOverride                       bool
	RequestReason                             string
	RequestTimeout                            time.Duration
	DefaultLabels                             map[string]string
	AddTerraformAttributionLabel              bool
	TerraformAttributionLabelAdditionStrategy string
	// PollInterval is passed to retry.StateChangeConf in common_operation.go
	// It controls the interval at which we poll for successful operations
	PollInterval time.Duration

	Client           *http.Client
	Context          context.Context
	UserAgent        string
	gRPCLoggingOptions []option.ClientOption

	TokenSource oauth2.TokenSource

	{{ range $product := $.Products }}
	{{ $product.Name }}BasePath string
	{{- end }}

	CloudBillingBasePath string
	ContainerBasePath string
	DataflowBasePath string
	IamCredentialsBasePath string
	ResourceManagerV3BasePath string
	IAMBasePath string
	CloudIoTBasePath string
	BigtableAdminBasePath string
	TagsLocationBasePath string

	// DCL
	ContainerAwsBasePath string
	ContainerAzureBasePath string
	ApikeysBasePath string
	AssuredWorkloadsBasePath string
	CloudResourceManagerBasePath string
	FirebaserulesBasePath string
	RecaptchaEnterpriseBasePath string

	RequestBatcherServiceUsage *RequestBatcher
	RequestBatcherIam          *RequestBatcher
}

{{- range $product := $.Products }}
const {{ $product.Name }}BasePathKey = "{{ $product.Name }}"
{{- end }}
const CloudBillingBasePathKey = "CloudBilling"
const ContainerBasePathKey = "Container"
const DataflowBasePathKey = "Dataflow"
const IAMBasePathKey = "IAM"
const IamCredentialsBasePathKey = "IamCredentials"
const ResourceManagerV3BasePathKey = "ResourceManagerV3"
const BigtableAdminBasePathKey = "BigtableAdmin"
const ContainerAwsBasePathKey = "ContainerAws"
const ContainerAzureBasePathKey = "ContainerAzure"
const TagsLocationBasePathKey = "TagsLocation"

// Generated product base paths
var DefaultBasePaths = map[string]string{
{{- range $product := $.Products }}
	{{ $product.Name }}BasePathKey : "{{ $product.BaseUrl }}",
{{- end }}
	CloudBillingBasePathKey : "https://cloudbilling.googleapis.com/v1/",
{{- if eq $.TargetVersionName "ga" }}
	ContainerBasePathKey : "https://container.googleapis.com/v1/",
{{- else }}
	ContainerBasePathKey : "https://container.googleapis.com/v1beta1/",
{{- end }}
	DataflowBasePathKey : "https://dataflow.googleapis.com/v1b3/",
	IAMBasePathKey : "https://iam.googleapis.com/v1/",
	IamCredentialsBasePathKey : "https://iamcredentials.googleapis.com/v1/",
	ResourceManagerV3BasePathKey : "https://cloudresourcemanager.googleapis.com/v3/",
	BigtableAdminBasePathKey : "https://bigtableadmin.googleapis.com/v2/",
	TagsLocationBasePathKey: "https://{{"{{"}}location{{"}}"}}-cloudresourcemanager.googleapis.com/v3/",
	// DCL
	ContainerAwsBasePathKey: "https://{{"{{"}}location{{"}}"}}-gkemulticloud.googleapis.com/v1/",
	ContainerAzureBasePathKey: "https://{{"{{"}}location{{"}}"}}-gkemulticloud.googleapis.com/v1/",
	ApikeysEndpointEntryKey: "https://apikeys.googleapis.com/v2/",
{{- if eq $.TargetVersionName "ga" }}
	AssuredWorkloadsEndpointEntryKey: "https://{{"{{"}}location{{"}}"}}-assuredworkloads.googleapis.com/v1beta1/",
{{- else }}
	AssuredWorkloadsEndpointEntryKey: "https://{{"{{"}}location{{"}}"}}-assuredworkloads.googleapis.com/v1/",
{{- end }}
	CloudResourceManagerEndpointEntryKey: "https://cloudresourcemanager.googleapis.com/",
	FirebaserulesEndpointEntryKey: "https://firebaserules.googleapis.com/v1/",
	RecaptchaEnterpriseEndpointEntryKey: "https://recaptchaenterprise.googleapis.com/v1/",
}

var DefaultClientScopes = []string{
	"https://www.googleapis.com/auth/cloud-platform",
	"https://www.googleapis.com/auth/userinfo.email",
}

const AttributionKey = "goog-terraform-provisioned"
const AttributionValue = "true"
const CreateOnlyAttributionStrategy = "CREATION_ONLY"
const ProactiveAttributionStrategy = "PROACTIVE"

func HandleSDKDefaults(d *schema.ResourceData) error {
	if d.Get("impersonate_service_account") == "" {
		d.Set("impersonate_service_account", MultiEnvDefault([]string{
			"GOOGLE_IMPERSONATE_SERVICE_ACCOUNT",
		}, nil))
	}

	if d.Get("project") == "" {
		d.Set("project", MultiEnvDefault([]string{
			"GOOGLE_PROJECT",
			"GOOGLE_CLOUD_PROJECT",
			"GCLOUD_PROJECT",
			"CLOUDSDK_CORE_PROJECT",
		}, nil))
	}

	if d.Get("billing_project") == "" {
		d.Set("billing_project", MultiEnvDefault([]string{
			"GOOGLE_BILLING_PROJECT",
		}, nil))
	}

	if d.Get("region") == "" {
		d.Set("region", MultiEnvDefault([]string{
			"GOOGLE_REGION",
			"GCLOUD_REGION",
			"CLOUDSDK_COMPUTE_REGION",
		}, nil))
	}

	if d.Get("zone") == "" {
		d.Set("zone", MultiEnvDefault([]string{
			"GOOGLE_ZONE",
			"GCLOUD_ZONE",
			"CLOUDSDK_COMPUTE_ZONE",
		}, nil))
	}

	if _, ok := d.GetOkExists("user_project_override"); !ok {
		override := MultiEnvDefault([]string{
			"USER_PROJECT_OVERRIDE",
		}, nil)

		if override != nil {
			b, err := strconv.ParseBool(override.(string))
			if err != nil {
				return err
			}
			d.Set("user_project_override", b)
		}
	}

	if d.Get("request_reason") == "" {
		d.Set("request_reason", MultiEnvDefault([]string{
			"CLOUDSDK_CORE_REQUEST_REASON",
		}, nil))
	}
	return nil
}

func SetEndpointDefaults(d *schema.ResourceData) error {
	// Generated Products
	{{- range $product := $.Products }}
	if d.Get("{{ underscore $product.Name }}_custom_endpoint") == "" {
		d.Set("{{ underscore $product.Name }}_custom_endpoint", MultiEnvDefault([]string{
			"GOOGLE_{{ upper (underscore $product.Name) }}_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[{{ $product.Name }}BasePathKey]))
	}
	{{- end }}

	if d.Get(CloudBillingCustomEndpointEntryKey) == "" {
		d.Set(CloudBillingCustomEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_CLOUD_BILLING_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[CloudBillingBasePathKey]))
	}

	if d.Get(ComposerCustomEndpointEntryKey) == "" {
		d.Set(ComposerCustomEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_COMPOSER_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[ComposerBasePathKey]))
	}

	if d.Get(ContainerCustomEndpointEntryKey) == "" {
		d.Set(ContainerCustomEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_CONTAINER_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[ContainerBasePathKey]))
	}

	if d.Get(DataflowCustomEndpointEntryKey) == "" {
		d.Set(DataflowCustomEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_DATAFLOW_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[DataflowBasePathKey]))
	}

	if d.Get(IamCredentialsCustomEndpointEntryKey) == "" {
		d.Set(IamCredentialsCustomEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_IAM_CREDENTIALS_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[IamCredentialsBasePathKey]))
	}

	if d.Get(ResourceManagerV3CustomEndpointEntryKey) == "" {
		d.Set(ResourceManagerV3CustomEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_RESOURCE_MANAGER_V3_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[ResourceManagerV3BasePathKey]))
	}

	{{ if ne $.TargetVersionName `ga` -}}
	if d.Get(RuntimeConfigCustomEndpointEntryKey) == "" {
		d.Set(RuntimeConfigCustomEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_RUNTIMECONFIG_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[RuntimeConfigBasePathKey]))
	}
	{{- end }}

	if d.Get(IAMCustomEndpointEntryKey) == "" {
		d.Set(IAMCustomEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_IAM_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[IAMBasePathKey]))
	}

	if d.Get(ServiceNetworkingCustomEndpointEntryKey) == "" {
		d.Set(ServiceNetworkingCustomEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_SERVICE_NETWORKING_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[ServiceNetworkingBasePathKey]))
	}

	if d.Get(TagsLocationCustomEndpointEntryKey) == "" {
		d.Set(TagsLocationCustomEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_TAGS_LOCATION_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[TagsLocationBasePathKey]))
	}

	// DCL endpoints - these are hardcoded as a workaround for the DCL not providing a way to
	// determine base paths at generation time.

	if d.Get(ContainerAwsCustomEndpointEntryKey) == "" {
		d.Set(ContainerAwsCustomEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_CONTAINERAWS_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[ContainerAwsBasePathKey]))
	}

	if d.Get(ContainerAzureCustomEndpointEntryKey) == "" {
		d.Set(ContainerAzureCustomEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_CONTAINERAZURE_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[ContainerAzureBasePathKey]))
	}
	if d.Get(ApikeysEndpointEntryKey) == "" {
		d.Set(ApikeysEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_APIKEYS_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[ApikeysEndpointEntryKey]))
	}
	if d.Get(AssuredWorkloadsEndpointEntryKey) == "" {
		d.Set(AssuredWorkloadsEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_ASSURED_WORKLOADS_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[AssuredWorkloadsEndpointEntryKey]))
	}
	if d.Get(CloudResourceManagerEndpointEntryKey) == "" {
		d.Set(CloudResourceManagerEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_CLOUD_RESOURCE_MANAGER_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[CloudResourceManagerEndpointEntryKey]))
	}
	if d.Get(FirebaserulesEndpointEntryKey) == "" {
		d.Set(FirebaserulesEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_FIREBASERULES_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[FirebaserulesEndpointEntryKey]))
	}
	if d.Get(RecaptchaEnterpriseEndpointEntryKey) == "" {
		d.Set(RecaptchaEnterpriseEndpointEntryKey, MultiEnvDefault([]string{
			"GOOGLE_RECAPTCHA_ENTERPRISE_CUSTOM_ENDPOINT",
		}, DefaultBasePaths[RecaptchaEnterpriseEndpointEntryKey]))
	}

	return nil
}

func (c *Config) LoadAndValidate(ctx context.Context) error {
	if len(c.Scopes) == 0 {
		c.Scopes = DefaultClientScopes
	}

	c.Context = ctx

	tokenSource, err := c.getTokenSource(ctx, c.Scopes, false)
	if err != nil {
		return err
	}

	c.TokenSource = tokenSource
	cleanCtx := context.WithValue(ctx, oauth2.HTTPClient, cleanhttp.DefaultClient())
	clientOptions := []option.ClientOption{option.WithTokenSource(tokenSource)}

	// The client libraries allow setting the GOOGLE_CLOUD_QUOTA_PROJECT environment variable 
	// directly, which unintentionally takes precedence over provider settings. Ensure that 
	// provider settings take precedence by applying to the client library's client directly
	// b/360405077#comment8 - go/tpg-issue/17882
	if c.UserProjectOverride && c.BillingProject != "" {
		quotaProject :=  c.BillingProject
		clientOptions = append(clientOptions, option.WithQuotaProject(quotaProject))
	}

	// 1. MTLS TRANSPORT/CLIENT - sets up proper auth headers
	client, _, err := transport.NewHTTPClient(cleanCtx, clientOptions...)
	if err != nil {
		return err
	}

	// Userinfo is fetched before request logging is enabled to reduce additional noise.
	err = c.logGoogleIdentities(ctx)
	if err != nil {
		return err
	}

	// 2. Logging Transport - ensure we log HTTP requests to GCP APIs.
	loggingTransport := logging.NewTransport("Google", client.Transport)

	// 3. Retry Transport - retries common temporary errors
	// Keep order for wrapping logging so we log each retried request as well.
	// This value should be used if needed to create shallow copies with additional retry predicates.
	// See ClientWithAdditionalRetries
	retryTransport := NewTransportWithDefaultRetries(loggingTransport)

	// 4. Header Transport - outer wrapper to inject additional headers we want to apply
	// before making requests
	headerTransport := NewTransportWithHeaders(retryTransport)
	if c.RequestReason != "" {
		headerTransport.Set("X-Goog-Request-Reason", c.RequestReason)
	}

	// Ensure $userProject is set for all HTTP requests using the client if specified by the provider config
	// See https://cloud.google.com/apis/docs/system-parameters
	// option.WithQuotaProject automatically sets the quota project in the client.
	// However, this setting won't appear in our request logs since our logging
	// transport sits above the Google client's internal transport. To ensure
	// visibility in debug logging, we explicitly set the quota project here as well.
	if c.UserProjectOverride && c.BillingProject != "" {
		headerTransport.Set("X-Goog-User-Project", c.BillingProject)
	}

	// Set final transport value.
	client.Transport = headerTransport

	// This timeout is a timeout per HTTP request, not per logical operation.
	client.Timeout = c.synchronousTimeout()

	c.Client = client
	c.Context = ctx
	c.Region = GetRegionFromRegionSelfLink(c.Region)
	c.RequestBatcherServiceUsage = NewRequestBatcher("Service Usage", ctx, c.BatchingConfig)
	c.RequestBatcherIam = NewRequestBatcher("IAM", ctx, c.BatchingConfig)
	c.PollInterval = 10 * time.Second

	// gRPC Logging setup
	logger := logrus.StandardLogger()

	logrus.SetLevel(logrus.DebugLevel)
	logrus.SetFormatter(&Formatter{
		TimestampFormat: "2006/01/02 15:04:05",
		LogFormat:       "%time% [%lvl%] %msg% \n",
	})
	logger.SetOutput(log.Writer())

	alwaysLoggingDeciderClient := func(ctx context.Context, fullMethodName string) bool { return true }
	c.gRPCLoggingOptions = append(
		c.gRPCLoggingOptions, option.WithGRPCDialOption(grpc.WithUnaryInterceptor(
			grpc_logrus.PayloadUnaryClientInterceptor(logrus.NewEntry(logger), alwaysLoggingDeciderClient))),
		option.WithGRPCDialOption(grpc.WithStreamInterceptor(
			grpc_logrus.PayloadStreamClientInterceptor(logrus.NewEntry(logger), alwaysLoggingDeciderClient))),
	)

	return nil
}

// getExternalAccountConfig returns an externalaccount.Config based on the Config object.
// The external account config is intended to be used to create a token source.
func (c *Config) getExternalAccountConfig(clientScopes []string) externalaccount.Config {
	eaConfig := externalaccount.Config{
		Audience:         c.ExternalCredentials.Audience,
		SubjectTokenType: "urn:ietf:params:oauth:token-type:jwt",
		ServiceAccountImpersonationURL: fmt.Sprintf("https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/%s:generateAccessToken", c.ExternalCredentials.ServiceAccountEmail),
		Scopes:               clientScopes,
		SubjectTokenSupplier: c.ExternalCredentials,
	}
	// If UniverseDomain is set, the externalaccount package will use it to set the TokenURL (https://sts.UNIVERSE_DOMAIN/v1/token). Otherwise TokenURL defaults to https://sts.googleapis.com/v1/token
	if c.UniverseDomain != "" && c.UniverseDomain != "googleapis.com" {
		eaConfig.UniverseDomain = c.UniverseDomain
	}
	return eaConfig
}


func ExpandProviderBatchingConfig(v interface{}) (*BatchingConfig, error) {
	config := &BatchingConfig{
		SendAfter:      time.Second * DefaultBatchSendIntervalSec,
		EnableBatching: true,
	}

	if v == nil {
		return config, nil
	}
	ls := v.([]interface{})
	if len(ls) == 0 || ls[0] == nil {
		return config, nil
	}

	cfgV := ls[0].(map[string]interface{})
	if sendAfterV, ok := cfgV["send_after"]; ok && sendAfterV != "" {
		SendAfter, err := time.ParseDuration(sendAfterV.(string))
		if err != nil {
			return nil, fmt.Errorf("unable to parse duration from 'send_after' value %q", sendAfterV)
		}
		config.SendAfter = SendAfter
	}

	if enable, ok := cfgV["enable_batching"]; ok {
		config.EnableBatching = enable.(bool)
	}

	return config, nil
}

func (c *Config) synchronousTimeout() time.Duration {
	if c.RequestTimeout == 0 {
		return 120 * time.Second
	}
	return c.RequestTimeout
}

// Print Identities executing terraform API Calls.
func (c *Config) logGoogleIdentities(ctx context.Context) error {
	if c.ImpersonateServiceAccount == "" {

	tokenSource, err := c.getTokenSource(ctx, c.Scopes, true)
		if err != nil {
			return err
		}
		c.Client = oauth2.NewClient(c.Context, tokenSource) // c.Client isn't initialised fully when this code is called.

		email, err := GetCurrentUserEmail(c, c.UserAgent)
		if err != nil {
			log.Printf("[INFO] error retrieving userinfo for your provider credentials. have you enabled the 'https://www.googleapis.com/auth/userinfo.email' scope? error: %s", err)
		}

		log.Printf("[INFO] Terraform is using this identity: %s", email)

		return nil

	}

	// Drop Impersonated ClientOption from OAuth2 TokenSource to infer original identity

	tokenSource, err := c.getTokenSource(ctx, c.Scopes, true)
	if err != nil {
		return err
	}
	c.Client = oauth2.NewClient(c.Context, tokenSource) // c.Client isn't initialised fully when this code is called.

	email, err := GetCurrentUserEmail(c, c.UserAgent)
	if err != nil {
		log.Printf("[INFO] error retrieving userinfo for your provider credentials. have you enabled the 'https://www.googleapis.com/auth/userinfo.email' scope? error: %s", err)
	}

	log.Printf("[INFO] Terraform is configured with service account impersonation, original identity: %s, impersonated identity: %s", email, c.ImpersonateServiceAccount)

	// Add the Impersonated ClientOption back in to the OAuth2 TokenSource

	tokenSource, err = c.getTokenSource(ctx, c.Scopes, false)
	if err != nil {
		return err
	}
	c.Client = oauth2.NewClient(c.Context, tokenSource) // c.Client isn't initialised fully when this code is called.

	return nil
}

// Get a TokenSource based on the Google Credentials configured.
// If initialCredentialsOnly is true, don't follow the impersonation settings and return the initial set of creds.
func (c *Config) getTokenSource(ctx context.Context, clientScopes []string, initialCredentialsOnly bool) (oauth2.TokenSource, error) {

	if c.ExternalCredentials != nil {
		log.Printf("[INFO] Using external credentials")
		eaConfig := c.getExternalAccountConfig(clientScopes)
		creds, err := externalaccount.NewTokenSource(ctx, eaConfig)
		if err != nil {
			return nil, fmt.Errorf("error creating token source from external credentials: %s", err)
		}
		return creds, nil
	}

	creds, err := c.GetCredentials(clientScopes, initialCredentialsOnly)
	if err != nil {
		return nil, fmt.Errorf("%s", err)
	}
	return creds.TokenSource, nil
}

// Methods to create new services from config
// Some base paths below need the version and possibly more of the path
// set on them. The client libraries are inconsistent about which values they need;
// while most only want the host URL, some older ones also want the version and some
// of those "projects" as well. You can find out if this is required by looking at
// the basePath value in the client library file.
func (c *Config) NewCertificateManagerClient(userAgent string) *certificatemanager.Service {
	certificateManagerClientBasePath := RemoveBasePathVersion(c.CertificateManagerBasePath)
	log.Printf("[INFO] Instantiating Certificate Manager client for path %s", certificateManagerClientBasePath)
	clientCertificateManager, err := certificatemanager.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client certificate manager: %s", err)
		return nil
	}
	clientCertificateManager.UserAgent = userAgent
	clientCertificateManager.BasePath = certificateManagerClientBasePath

	return clientCertificateManager
}

func (c *Config) NewComputeClient(userAgent string) *compute.Service {
	log.Printf("[INFO] Instantiating GCE client for path %s", c.ComputeBasePath)
	clientCompute, err := compute.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client compute: %s", err)
		return nil
	}
	clientCompute.UserAgent = userAgent
	clientCompute.BasePath = c.ComputeBasePath

	return clientCompute
}

func (c *Config) NewContainerClient(userAgent string) *container.Service {
	containerClientBasePath := RemoveBasePathVersion(c.ContainerBasePath)
	log.Printf("[INFO] Instantiating GKE client for path %s", containerClientBasePath)
	clientContainer, err := container.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client container: %s", err)
		return nil
	}
	clientContainer.UserAgent = userAgent
	clientContainer.BasePath = containerClientBasePath

	return clientContainer
}

func (c *Config) NewDnsClient(userAgent string) *dns.Service {
	dnsClientBasePath := RemoveBasePathVersion(c.DNSBasePath)
	dnsClientBasePath = strings.ReplaceAll(dnsClientBasePath, "/dns/", "")
	log.Printf("[INFO] Instantiating Google Cloud DNS client for path %s", dnsClientBasePath)
	clientDns, err := dns.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client dns: %s", err)
		return nil
	}
	clientDns.UserAgent = userAgent
	clientDns.BasePath = dnsClientBasePath

	return clientDns
}

{{- if ne $.TargetVersionName "ga" }}
func (c *Config) NewFirebaseClient(ctx context.Context, userAgent string) *firebase.Service {
	firebaseClientBasePath := RemoveBasePathVersion(c.FirebaseBasePath)
	firebaseClientBasePath = strings.ReplaceAll(firebaseClientBasePath, "/firebase/", "")
	log.Printf("[INFO] Instantiating Google Cloud firebase client for path %s", firebaseClientBasePath)
	clientFirebase, err := firebase.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client firebase: %s", err)
		return nil
	}
	clientFirebase.UserAgent = userAgent
	clientFirebase.BasePath = firebaseClientBasePath

	return clientFirebase
}
{{- end }}

func (c *Config) NewKmsClientWithCtx(ctx context.Context, userAgent string) *cloudkms.Service {
	kmsClientBasePath := RemoveBasePathVersion(c.KMSBasePath)
	log.Printf("[INFO] Instantiating Google Cloud KMS client for path %s", kmsClientBasePath)
	clientKms, err := cloudkms.NewService(ctx, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client kms: %s", err)
		return nil
	}
	clientKms.UserAgent = userAgent
	clientKms.BasePath = kmsClientBasePath

	return clientKms
}

func (c *Config) NewKmsClient(userAgent string) *cloudkms.Service {
	return c.NewKmsClientWithCtx(c.Context, userAgent)
}

func (c *Config) NewLoggingClient(userAgent string) *cloudlogging.Service {
	loggingClientBasePath := RemoveBasePathVersion(c.LoggingBasePath)
	log.Printf("[INFO] Instantiating Google Stackdriver Logging client for path %s", loggingClientBasePath)
	clientLogging, err := cloudlogging.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client logging: %s", err)
		return nil
	}
	clientLogging.UserAgent = userAgent
	clientLogging.BasePath = loggingClientBasePath

	return clientLogging
}

func (c *Config) NewStorageClient(userAgent string) *storage.Service {
	storageClientBasePath := c.StorageBasePath
	log.Printf("[INFO] Instantiating Google Storage client for path %s", storageClientBasePath)
	clientStorage, err := storage.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client storage: %s", err)
		return nil
	}
	clientStorage.UserAgent = userAgent
	clientStorage.BasePath = storageClientBasePath

	return clientStorage
}

// For object uploads, we need to override the specific timeout because they are long, synchronous operations.
func (c *Config) NewStorageClientWithTimeoutOverride(userAgent string, timeout time.Duration) *storage.Service {
	storageClientBasePath := c.StorageBasePath
	log.Printf("[INFO] Instantiating Google Storage client for path %s", storageClientBasePath)
	// Copy the existing HTTP client (which has no unexported fields [as of Oct 2021 at least], so this is safe).
	// We have to do this because otherwise we will accidentally change the timeout for all other
	// synchronous operations, which would not be desirable.
	httpClient := &http.Client{
		Transport:     c.Client.Transport,
		CheckRedirect: c.Client.CheckRedirect,
		Jar:           c.Client.Jar,
		Timeout:       timeout,
	}
	clientStorage, err := storage.NewService(c.Context, option.WithHTTPClient(httpClient))
	if err != nil {
		log.Printf("[WARN] Error creating client storage: %s", err)
		return nil
	}
	clientStorage.UserAgent = userAgent
	clientStorage.BasePath = storageClientBasePath

	return clientStorage
}

func (c *Config) NewSqlAdminClient(userAgent string) *sqladmin.Service {
	sqlClientBasePath := RemoveBasePathVersion(RemoveBasePathVersion(c.SQLBasePath))
	log.Printf("[INFO] Instantiating Google SqlAdmin client for path %s", sqlClientBasePath)
	clientSqlAdmin, err := sqladmin.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client storage: %s", err)
		return nil
	}
	clientSqlAdmin.UserAgent = userAgent
	clientSqlAdmin.BasePath = sqlClientBasePath

	return clientSqlAdmin
}

func (c *Config) NewBackupDRClient(userAgent string) *backupdr.Service {
	backupdrClientBasePath := RemoveBasePathVersion(RemoveBasePathVersion(c.BackupDRBasePath))
	log.Printf("[INFO] Instantiating Google SqlAdmin client for path %s", backupdrClientBasePath)
	clientBackupdrAdmin, err := backupdr.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client storage: %s", err)
		return nil
	}
	clientBackupdrAdmin.UserAgent = userAgent
	clientBackupdrAdmin.BasePath = backupdrClientBasePath

	return clientBackupdrAdmin
}

func (c *Config) NewPubsubClient(userAgent string) *pubsub.Service {
	pubsubClientBasePath := RemoveBasePathVersion(c.PubsubBasePath)
	log.Printf("[INFO] Instantiating Google Pubsub client for path %s", pubsubClientBasePath)
	wrappedPubsubClient := ClientWithAdditionalRetries(c.Client, PubsubTopicProjectNotReady)
	clientPubsub, err := pubsub.NewService(c.Context, option.WithHTTPClient(wrappedPubsubClient))
	if err != nil {
		log.Printf("[WARN] Error creating client pubsub: %s", err)
		return nil
	}
	clientPubsub.UserAgent = userAgent
	clientPubsub.BasePath = pubsubClientBasePath

	return clientPubsub
}

func (c *Config) NewDataflowClient(userAgent string) *dataflow.Service {
	dataflowClientBasePath := RemoveBasePathVersion(c.DataflowBasePath)
	log.Printf("[INFO] Instantiating Google Dataflow client for path %s", dataflowClientBasePath)
	clientDataflow, err := dataflow.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client dataflow: %s", err)
		return nil
	}
	clientDataflow.UserAgent = userAgent
	clientDataflow.BasePath = dataflowClientBasePath

	return clientDataflow
}

func (c *Config) NewResourceManagerClient(userAgent string) *cloudresourcemanager.Service {
	resourceManagerBasePath := RemoveBasePathVersion(c.ResourceManagerBasePath)
	log.Printf("[INFO] Instantiating Google Cloud ResourceManager client for path %s", resourceManagerBasePath)
	clientResourceManager, err := cloudresourcemanager.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client resource manager: %s", err)
		return nil
	}
	clientResourceManager.UserAgent = userAgent
	clientResourceManager.BasePath = resourceManagerBasePath

	return clientResourceManager
}

func (c *Config) NewResourceManagerV3Client(userAgent string) *resourceManagerV3.Service {
	resourceManagerV3BasePath := RemoveBasePathVersion(c.ResourceManagerV3BasePath)
	log.Printf("[INFO] Instantiating Google Cloud ResourceManager V3 client for path %s", resourceManagerV3BasePath)
	clientResourceManagerV3, err := resourceManagerV3.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client resource manager v3: %s", err)
		return nil
	}
	clientResourceManagerV3.UserAgent = userAgent
	clientResourceManagerV3.BasePath = resourceManagerV3BasePath

	return clientResourceManagerV3
}

{{ if ne $.TargetVersionName `ga` -}}
func(c *Config) NewRuntimeconfigClient(userAgent string) *runtimeconfig.Service {
	runtimeConfigClientBasePath := RemoveBasePathVersion(c.RuntimeConfigBasePath)
	log.Printf("[INFO] Instantiating Google Cloud Runtimeconfig client for path %s", runtimeConfigClientBasePath)
	clientRuntimeconfig, err := runtimeconfig.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client runtime config: %s", err)
		return nil
	}
	clientRuntimeconfig.UserAgent = userAgent
	clientRuntimeconfig.BasePath = runtimeConfigClientBasePath

	return clientRuntimeconfig
}
{{- end }}

func (c *Config) NewIamClient(userAgent string) *iam.Service {
	iamClientBasePath := RemoveBasePathVersion(c.IAMBasePath)
	log.Printf("[INFO] Instantiating Google Cloud IAM client for path %s", iamClientBasePath)
	clientIAM, err := iam.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client iam: %s", err)
		return nil
	}
	clientIAM.UserAgent = userAgent
	clientIAM.BasePath = iamClientBasePath

	return clientIAM
}

func (c *Config) NewIamCredentialsClient(userAgent string) *iamcredentials.Service {
	iamCredentialsClientBasePath := RemoveBasePathVersion(c.IamCredentialsBasePath)
	log.Printf("[INFO] Instantiating Google Cloud IAMCredentials client for path %s", iamCredentialsClientBasePath)
	clientIamCredentials, err := iamcredentials.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client iam credentials: %s", err)
		return nil
	}
	clientIamCredentials.UserAgent = userAgent
	clientIamCredentials.BasePath = iamCredentialsClientBasePath

	return clientIamCredentials
}

func (c *Config) NewServiceManClient(userAgent string) *servicemanagement.APIService {
	serviceManagementClientBasePath := RemoveBasePathVersion(c.ServiceManagementBasePath)
	log.Printf("[INFO] Instantiating Google Cloud Service Management client for path %s", serviceManagementClientBasePath)
	clientServiceMan, err := servicemanagement.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client service management: %s", err)
		return nil
	}
	clientServiceMan.UserAgent = userAgent
	clientServiceMan.BasePath = serviceManagementClientBasePath

	return clientServiceMan
}

func (c *Config) NewServiceUsageClient(userAgent string) *serviceusage.Service {
	serviceUsageClientBasePath := RemoveBasePathVersion(c.ServiceUsageBasePath)
	log.Printf("[INFO] Instantiating Google Cloud Service Usage client for path %s", serviceUsageClientBasePath)
	clientServiceUsage, err := serviceusage.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client service usage: %s", err)
		return nil
	}
	clientServiceUsage.UserAgent = userAgent
	clientServiceUsage.BasePath = serviceUsageClientBasePath

	return clientServiceUsage
}

func (c *Config) NewBillingClient(userAgent string) *cloudbilling.APIService {
	cloudBillingClientBasePath := RemoveBasePathVersion(c.CloudBillingBasePath)
	log.Printf("[INFO] Instantiating Google Cloud Billing client for path %s", cloudBillingClientBasePath)
	clientBilling, err := cloudbilling.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client billing: %s", err)
		return nil
	}
	clientBilling.UserAgent = userAgent
	clientBilling.BasePath = cloudBillingClientBasePath

	return clientBilling
}

func (c *Config) NewBuildClient(userAgent string) *cloudbuild.Service {
	cloudBuildClientBasePath := RemoveBasePathVersion(c.CloudBuildBasePath)
	log.Printf("[INFO] Instantiating Google Cloud Build client for path %s", cloudBuildClientBasePath)
	clientBuild, err := cloudbuild.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client build: %s", err)
		return nil
	}
	clientBuild.UserAgent = userAgent
	clientBuild.BasePath = cloudBuildClientBasePath

	return clientBuild
}

func (c *Config) NewCloudFunctionsClient(userAgent string) *cloudfunctions.Service {
	cloudFunctionsClientBasePath := RemoveBasePathVersion(c.CloudFunctionsBasePath)
	log.Printf("[INFO] Instantiating Google Cloud CloudFunctions Client for path %s", cloudFunctionsClientBasePath)
	clientCloudFunctions, err := cloudfunctions.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client cloud functions: %s", err)
		return nil
	}
	clientCloudFunctions.UserAgent = userAgent
	clientCloudFunctions.BasePath = cloudFunctionsClientBasePath

	return clientCloudFunctions
}

func (c *Config) NewSourceRepoClient(userAgent string) *sourcerepo.Service {
	sourceRepoClientBasePath := RemoveBasePathVersion(c.SourceRepoBasePath)
	log.Printf("[INFO] Instantiating Google Cloud Source Repo client for path %s", sourceRepoClientBasePath)
	clientSourceRepo, err := sourcerepo.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client source repo: %s", err)
		return nil
	}
	clientSourceRepo.UserAgent = userAgent
	clientSourceRepo.BasePath = sourceRepoClientBasePath

	return clientSourceRepo
}

func (c *Config) NewBigQueryClient(userAgent string) *bigquery.Service {
	bigQueryClientBasePath := c.BigQueryBasePath
	log.Printf("[INFO] Instantiating Google Cloud BigQuery client for path %s", bigQueryClientBasePath)
	wrappedBigQueryClient := ClientWithAdditionalRetries(c.Client, IamMemberMissing)
	clientBigQuery, err := bigquery.NewService(c.Context, option.WithHTTPClient(wrappedBigQueryClient))
	if err != nil {
		log.Printf("[WARN] Error creating client big query: %s", err)
		return nil
	}
	clientBigQuery.UserAgent = userAgent
	clientBigQuery.BasePath = bigQueryClientBasePath

	return clientBigQuery
}

func (c *Config) NewSpannerClient(userAgent string) *spanner.Service {
	spannerClientBasePath := RemoveBasePathVersion(c.SpannerBasePath)
	log.Printf("[INFO] Instantiating Google Cloud Spanner client for path %s", spannerClientBasePath)
	clientSpanner, err := spanner.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client source repo: %s", err)
		return nil
	}
	clientSpanner.UserAgent = userAgent
	clientSpanner.BasePath = spannerClientBasePath

	return clientSpanner
}

func (c *Config) NewDataprocClient(userAgent string) *dataproc.Service {
	dataprocClientBasePath := RemoveBasePathVersion(c.DataprocBasePath)
	log.Printf("[INFO] Instantiating Google Cloud Dataproc client for path %s", dataprocClientBasePath)
	clientDataproc, err := dataproc.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client dataproc: %s", err)
		return nil
	}
	clientDataproc.UserAgent = userAgent
	clientDataproc.BasePath = dataprocClientBasePath

	return clientDataproc
}

func (c *Config) NewCloudIoTClient(userAgent string) *cloudiot.Service {
	cloudIoTClientBasePath := RemoveBasePathVersion(c.CloudIoTBasePath)
	log.Printf("[INFO] Instantiating Google Cloud IoT Core client for path %s", cloudIoTClientBasePath)
	clientCloudIoT, err := cloudiot.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client cloud iot: %s", err)
		return nil
	}
	clientCloudIoT.UserAgent = userAgent
	clientCloudIoT.BasePath = cloudIoTClientBasePath

	return clientCloudIoT
}

func (c *Config) NewAppEngineClient(userAgent string) *appengine.APIService {
	appEngineClientBasePath := RemoveBasePathVersion(c.AppEngineBasePath)
	log.Printf("[INFO] Instantiating App Engine client for path %s", appEngineClientBasePath)
	clientAppEngine, err := appengine.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client appengine: %s", err)
		return nil
	}
	clientAppEngine.UserAgent = userAgent
	clientAppEngine.BasePath = appEngineClientBasePath

	return clientAppEngine
}

func (c *Config) NewComposerClient(userAgent string) *composer.Service {
	composerClientBasePath := RemoveBasePathVersion(c.ComposerBasePath)
	log.Printf("[INFO] Instantiating Cloud Composer client for path %s", composerClientBasePath)
	clientComposer, err := composer.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client composer: %s", err)
		return nil
	}
	clientComposer.UserAgent = userAgent
	clientComposer.BasePath = composerClientBasePath

	return clientComposer
}

func (c *Config) NewServiceNetworkingClient(userAgent string) *servicenetworking.APIService {
	serviceNetworkingClientBasePath := RemoveBasePathVersion(c.ServiceNetworkingBasePath)
	log.Printf("[INFO] Instantiating Service Networking client for path %s", serviceNetworkingClientBasePath)
	clientServiceNetworking, err := servicenetworking.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client service networking: %s", err)
		return nil
	}
	clientServiceNetworking.UserAgent = userAgent
	clientServiceNetworking.BasePath = serviceNetworkingClientBasePath

	return clientServiceNetworking
}

func (c *Config) NewStorageTransferClient(userAgent string) *storagetransfer.Service {
	storageTransferClientBasePath := RemoveBasePathVersion(c.StorageTransferBasePath)
	log.Printf("[INFO] Instantiating Google Cloud Storage Transfer client for path %s", storageTransferClientBasePath)
	clientStorageTransfer, err := storagetransfer.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client storage transfer: %s", err)
		return nil
	}
	clientStorageTransfer.UserAgent = userAgent
	clientStorageTransfer.BasePath = storageTransferClientBasePath

	return clientStorageTransfer
}

func (c *Config) NewHealthcareClient(userAgent string) *healthcare.Service {
	healthcareClientBasePath := RemoveBasePathVersion(c.HealthcareBasePath)
	log.Printf("[INFO] Instantiating Google Cloud Healthcare client for path %s", healthcareClientBasePath)
	clientHealthcare, err := healthcare.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client healthcare: %s", err)
		return nil
	}
	clientHealthcare.UserAgent = userAgent
	clientHealthcare.BasePath = healthcareClientBasePath

	return clientHealthcare
}

func (c *Config) NewCloudIdentityClient(userAgent string) *cloudidentity.Service {
	cloudidentityClientBasePath := RemoveBasePathVersion(c.CloudIdentityBasePath)
	log.Printf("[INFO] Instantiating Google Cloud CloudIdentity client for path %s", cloudidentityClientBasePath)
	clientCloudIdentity, err := cloudidentity.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client cloud identity: %s", err)
		return nil
	}
	clientCloudIdentity.UserAgent = userAgent
	clientCloudIdentity.BasePath = cloudidentityClientBasePath

	return clientCloudIdentity
}

func (c *Config) BigTableClientFactory(userAgent string) *BigtableClientFactory {
	bigtableClientFactory := &BigtableClientFactory{
		UserAgent:           userAgent,
		TokenSource:         c.TokenSource,
		gRPCLoggingOptions:  c.gRPCLoggingOptions,
		BillingProject:      c.BillingProject,
		UserProjectOverride: c.UserProjectOverride,
	}

	return bigtableClientFactory
}

// Unlike other clients, the Bigtable Admin client doesn't use a single
// service. Instead, there are several distinct services created off
// the base service object. To imitate most other handwritten clients,
// we expose those directly instead of providing the `Service` object
// as a factory.
func (c *Config) NewBigTableProjectsInstancesClient(userAgent string) *bigtableadmin.ProjectsInstancesService {
	bigtableAdminBasePath := RemoveBasePathVersion(c.BigtableAdminBasePath)
	log.Printf("[INFO] Instantiating Google Cloud BigtableAdmin for path %s", bigtableAdminBasePath)
	clientBigtable, err := bigtableadmin.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client big table projects instances: %s", err)
		return nil
	}
	clientBigtable.UserAgent = userAgent
	clientBigtable.BasePath = bigtableAdminBasePath
	clientBigtableProjectsInstances := bigtableadmin.NewProjectsInstancesService(clientBigtable)

	return clientBigtableProjectsInstances
}

func (c *Config) NewBigTableProjectsInstancesTablesClient(userAgent string) *bigtableadmin.ProjectsInstancesTablesService {
	bigtableAdminBasePath := RemoveBasePathVersion(c.BigtableAdminBasePath)
	log.Printf("[INFO] Instantiating Google Cloud BigtableAdmin for path %s", bigtableAdminBasePath)
	clientBigtable, err := bigtableadmin.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client projects instances tables: %s", err)
		return nil
	}
	clientBigtable.UserAgent = userAgent
	clientBigtable.BasePath = bigtableAdminBasePath
	clientBigtableProjectsInstancesTables := bigtableadmin.NewProjectsInstancesTablesService(clientBigtable)

	return clientBigtableProjectsInstancesTables
}

func (c *Config) NewCloudRunV2Client(userAgent string) *runadminv2.Service {
	runAdminV2ClientBasePath := RemoveBasePathVersion(RemoveBasePathVersion(c.CloudRunV2BasePath))
	log.Printf("[INFO] Instantiating Google Cloud Run Admin v2 client for path %s", runAdminV2ClientBasePath)
	clientRunAdminV2, err := runadminv2.NewService(c.Context, option.WithHTTPClient(c.Client))
	if err != nil {
		log.Printf("[WARN] Error creating client run admin: %s", err)
		return nil
	}
	clientRunAdminV2.UserAgent = userAgent
	clientRunAdminV2.BasePath = runAdminV2ClientBasePath

	return clientRunAdminV2
}

// StaticTokenSource is used to be able to identify static token sources without reflection.
type StaticTokenSource struct {
      oauth2.TokenSource
}

// Get a set of credentials with a given scope (clientScopes) based on the Config object.
// If initialCredentialsOnly is true, don't follow the impersonation settings and return the initial set of creds
// instead.
func (c *Config) GetCredentials(clientScopes []string, initialCredentialsOnly bool) (googleoauth.Credentials, error) {
	// UniverseDomain is assumed to be the previously set provider-configured value for access tokens
	if c.AccessToken != "" {
		contents, _, err := verify.PathOrContents(c.AccessToken)
		if err != nil {
			return googleoauth.Credentials{}, fmt.Errorf("Error loading access token: %s", err)
		}

		token := &oauth2.Token{AccessToken: contents}
		if c.ImpersonateServiceAccount != "" && !initialCredentialsOnly {
			opts := []option.ClientOption{option.WithTokenSource(oauth2.StaticTokenSource(token)), option.ImpersonateCredentials(c.ImpersonateServiceAccount, c.ImpersonateServiceAccountDelegates...), option.WithScopes(clientScopes...)}
			creds, err := transport.Creds(context.TODO(), opts...)
			if err != nil {
				return googleoauth.Credentials{}, err
			}
			return *creds, nil
		}

		log.Printf("[INFO] Authenticating using configured Google JSON 'access_token'...")
		log.Printf("[INFO]   -- Scopes: %s", clientScopes)
		return googleoauth.Credentials{
			TokenSource: StaticTokenSource{oauth2.StaticTokenSource(token)},
		}, nil
	}

	// UniverseDomain is set by the credential file's "universe_domain" field
	if c.Credentials != "" {
		contents, _, err := verify.PathOrContents(c.Credentials)
		if err != nil {
			return googleoauth.Credentials{}, fmt.Errorf("error loading credentials: %s", err)
		}

		var content map[string]any
		if err := json.Unmarshal([]byte(contents), &content); err != nil {
			return googleoauth.Credentials{}, fmt.Errorf("error unmarshaling credentials: %s", err)
		}

		if content["universe_domain"] != nil {
			c.UniverseDomain = content["universe_domain"].(string)
		} else {
			// Unset UniverseDomain if not found in credentials file
			c.UniverseDomain = ""
		}

		if c.ImpersonateServiceAccount != "" && !initialCredentialsOnly {
			jsonCreds, err := credentials.DetectDefault(&credentials.DetectOptions{
				Scopes:          clientScopes,
				CredentialsJSON: []byte(contents),
			})
			if err != nil {
				return googleoauth.Credentials{}, fmt.Errorf("error loading credentials: %s", err)
			}

			impersonateOpts := &impersonate.CredentialsOptions{
				TargetPrincipal: c.ImpersonateServiceAccount,
				Scopes:          clientScopes,
				Delegates:       c.ImpersonateServiceAccountDelegates,
				Credentials:     jsonCreds,
			}

			if c.UniverseDomain != "" && c.UniverseDomain != "googleapis.com" {
				impersonateOpts.UniverseDomain = c.UniverseDomain
			}

			authCred, err := impersonate.NewCredentials(impersonateOpts)
			if err != nil {
				return googleoauth.Credentials{}, fmt.Errorf("error loading credentials: %s", err)
			}

			creds := oauth2adapt.Oauth2CredentialsFromAuthCredentials(authCred)
			if err != nil {
				return googleoauth.Credentials{}, fmt.Errorf("error loading credentials: %s", err)
			}
			return *creds, nil
		}

		if c.UniverseDomain != "" && c.UniverseDomain != "googleapis.com" {
			creds, err := transport.Creds(c.Context, option.WithCredentialsJSON([]byte(contents)), option.WithScopes(clientScopes...), internaloption.EnableJwtWithScope())
			if err != nil {
				return googleoauth.Credentials{}, fmt.Errorf("unable to parse credentials from '%s': %s", contents, err)
			}
			log.Printf("[INFO] Authenticating using configured Google JSON 'credentials'...")
			log.Printf("[INFO]   -- Scopes: %s", clientScopes)
			log.Printf("[INFO]   -- Sending EnableJwtWithScope option")
			return *creds, nil
		} else {
			creds, err := transport.Creds(c.Context, option.WithCredentialsJSON([]byte(contents)), option.WithScopes(clientScopes...))
			if err != nil {
				return googleoauth.Credentials{}, fmt.Errorf("unable to parse credentials from '%s': %s", contents, err)
			}
			log.Printf("[INFO] Authenticating using configured Google JSON 'credentials'...")
			log.Printf("[INFO]   -- Scopes: %s", clientScopes)
			return *creds, nil
		}
	}

	var creds *googleoauth.Credentials
	var err error
	if c.ImpersonateServiceAccount != "" && !initialCredentialsOnly {
		defaultCreds, err := credentials.DetectDefault(&credentials.DetectOptions{
			Scopes: clientScopes,
		})
		if err != nil {
			return googleoauth.Credentials{}, fmt.Errorf("error loading credentials: %s", err)
		}

		impersonateOpts := &impersonate.CredentialsOptions{
			TargetPrincipal: c.ImpersonateServiceAccount,
			Scopes:          clientScopes,
			Delegates:       c.ImpersonateServiceAccountDelegates,
			Credentials:     defaultCreds,
		}

		if c.UniverseDomain != "" && c.UniverseDomain != "googleapis.com" {
			impersonateOpts.UniverseDomain = c.UniverseDomain
		}

		authCred, err := impersonate.NewCredentials(impersonateOpts)
		if err != nil {
			return googleoauth.Credentials{}, fmt.Errorf("error loading credentials: %s", err)
		}

		creds := oauth2adapt.Oauth2CredentialsFromAuthCredentials(authCred)
		if err != nil {
			return googleoauth.Credentials{}, fmt.Errorf("error loading credentials: %s", err)
		}
		return *creds, nil
	} else {
		log.Printf("[INFO] Authenticating using DefaultClient...")
		log.Printf("[INFO]   -- Scopes: %s", clientScopes)

		if c.UniverseDomain != "" && c.UniverseDomain != "googleapis.com" {
			log.Printf("[INFO]   -- Sending JwtWithScope option")
			creds, err = transport.Creds(context.Background(), option.WithScopes(clientScopes...), internaloption.EnableJwtWithScope())
			if err != nil {
				return googleoauth.Credentials{}, fmt.Errorf("Attempted to load application default credentials since neither `credentials` nor `access_token` was set in the provider block.  No credentials loaded. To use your gcloud credentials, run 'gcloud auth application-default login'.  Original error: %w", err)
			}
		} else {
			creds, err = transport.Creds(context.Background(), option.WithScopes(clientScopes...))
			if err != nil {
				return googleoauth.Credentials{}, fmt.Errorf("Attempted to load application default credentials since neither `credentials` nor `access_token` was set in the provider block.  No credentials loaded. To use your gcloud credentials, run 'gcloud auth application-default login'.  Original error: %w", err)
			}
		}
	}

	if creds.JSON != nil {
		var content map[string]any
		if err := json.Unmarshal([]byte(creds.JSON), &content); err != nil {
			log.Printf("[WARN] error unmarshaling credentials, skipping Universe Domain detection")
			c.UniverseDomain = ""
		} else if content["universe_domain"] != nil {
			c.UniverseDomain = content["universe_domain"].(string)
		} else {
			// Unset UniverseDomain if not found in ADC credentials file
			c.UniverseDomain = ""
		}
	} else {
		// creds.GetUniverseDomain may retrieve a domain from the metadata server
		ud, err := creds.GetUniverseDomain()
		if err != nil {
			log.Printf("[WARN] Error retrieving universe domain: %s", err)
		}
		c.UniverseDomain = ud
	}

	return *creds, nil
}

// Remove the `/{{"{{"}}version{{"}}"}}/` from a base path if present.
func RemoveBasePathVersion(url string) string {
	re := regexp.MustCompile(`(?P<base>http[s]://.*)(?P<version>/[^/]+?/$)`)
	return re.ReplaceAllString(url, "$1/")
}

// For a consumer of config.go that isn't a full fledged provider and doesn't
// have its own endpoint mechanism such as sweepers, init {{"{{"}}service{{"}}"}}BasePath
// values to a default. After using this, you should call config.LoadAndValidate.
func ConfigureBasePaths(c *Config) {
	// Generated Products
	{{- range $product := $.Products }}
	c.{{ $product.Name }}BasePath = DefaultBasePaths[{{ $product.Name }}BasePathKey]
	{{- end }}

	// Handwritten Products / Versioned / Atypical Entries
	c.CloudBillingBasePath = DefaultBasePaths[CloudBillingBasePathKey]
	c.ComposerBasePath = DefaultBasePaths[ComposerBasePathKey]
	c.ContainerBasePath = DefaultBasePaths[ContainerBasePathKey]
	c.DataprocBasePath = DefaultBasePaths[DataprocBasePathKey]
	c.DataflowBasePath = DefaultBasePaths[DataflowBasePathKey]
	c.IamCredentialsBasePath = DefaultBasePaths[IamCredentialsBasePathKey]
	c.ResourceManagerV3BasePath = DefaultBasePaths[ResourceManagerV3BasePathKey]
	c.IAMBasePath = DefaultBasePaths[IAMBasePathKey]
	c.BigQueryBasePath = DefaultBasePaths[BigQueryBasePathKey]
	c.BigtableAdminBasePath = DefaultBasePaths[BigtableAdminBasePathKey]
	c.TagsLocationBasePath = DefaultBasePaths[TagsLocationBasePathKey]

	// DCL
	c.ContainerAwsBasePath = DefaultBasePaths[ContainerAwsBasePathKey]
	c.ContainerAzureBasePath = DefaultBasePaths[ContainerAzureBasePathKey]
	c.ApikeysBasePath = DefaultBasePaths[ApikeysEndpointEntryKey]
	c.AssuredWorkloadsBasePath = DefaultBasePaths[AssuredWorkloadsEndpointEntryKey]
	c.CloudResourceManagerBasePath = DefaultBasePaths[CloudResourceManagerEndpointEntryKey]
	c.FirebaserulesBasePath = DefaultBasePaths[FirebaserulesEndpointEntryKey]
	c.RecaptchaEnterpriseBasePath = DefaultBasePaths[RecaptchaEnterpriseEndpointEntryKey]
}

func GetCurrentUserEmail(config *Config, userAgent string) (string, error) {
	ud := config.UniverseDomain
	if ud != "" && ud != "googleapis.com" {
		log.Printf("[INFO] Configured universe domain detected. Skipping user email retrieval.")
		return "", nil
	}

	// When environment variables UserProjectOverride and BillingProject are set for the provider,
	// the header X-Goog-User-Project is set for the API requests.
	// But it causes an error when calling GetCurrentUserEmail. Set the project to be "NO_BILLING_PROJECT_OVERRIDE".
	// And then it triggers the header X-Goog-User-Project to be set to empty string.

	// See https://github.com/golang/oauth2/issues/306 for a recommendation to do this from a Go maintainer
	// URL retrieved from https://accounts.google.com/.well-known/openid-configuration
	res, err := SendRequest(SendRequestOptions{
		Config:  config,
		Method:  "GET",
		Project: "NO_BILLING_PROJECT_OVERRIDE",
		// URL does not need to be universe domain-aware since we return early for non-GDU universes
		RawURL: "https://openidconnect.googleapis.com/v1/userinfo",
		UserAgent: userAgent,
	})

	if err != nil {
		return "", fmt.Errorf("error retrieving userinfo for your provider credentials. have you enabled the 'https://www.googleapis.com/auth/userinfo.email' scope? error: %s", err)
	}
	if res["email"] == nil {
		return "", fmt.Errorf("error retrieving email from userinfo. email was nil in the response.")
	}
	return res["email"].(string), nil
}

func MultiEnvSearch(ks []string) string {
	for _, k := range ks {
		if v := os.Getenv(k); v != "" {
			return v
		}
	}
	return ""
}

// MultiEnvDefault is a helper function that returns the value of the first
// environment variable in the given list that returns a non-empty value. If
// none of the environment variables return a value, the default value is
// returned.
func MultiEnvDefault(ks []string, dv interface{}) interface{} {
	for _, k := range ks {
		if v := os.Getenv(k); v != "" {
			return v
		}
	}
	return dv
}

func CustomEndpointValidator() validator.String {
	return stringvalidator.RegexMatches(regexp.MustCompile(`.*/[^/]+/$`), "")
}

// return the region a selfLink is referring to
func GetRegionFromRegionSelfLink(selfLink string) string {
	re := regexp.MustCompile("/compute/[a-zA-Z0-9]*/projects/[a-zA-Z0-9-]*/regions/([a-zA-Z0-9-]*)")
	switch {
	case re.MatchString(selfLink):
		if res := re.FindStringSubmatch(selfLink); len(res) == 2 && res[1] != "" {
			return res[1]
		}
	}
	return selfLink
}

func GetUniverseDomainFromMeta(meta interface{}) string {
	config := meta.(*Config)
	if config.UniverseDomain == "" {
		return "googleapis.com"
	}
	return config.UniverseDomain
}