config := meta.(*Config)

obj := make(map[string]interface{})
databaseProp, err := expandFirestoreFieldDatabase(d.Get("database"), d, config)
if err != nil {
	return err
} else if v, ok := d.GetOkExists("database"); !isEmptyValue(reflect.ValueOf(databaseProp)) && (ok || !reflect.DeepEqual(v, databaseProp)) {
	obj["database"] = databaseProp
}
collectionProp, err := expandFirestoreFieldCollection(d.Get("collection"), d, config)
if err != nil {
	return err
} else if v, ok := d.GetOkExists("collection"); !isEmptyValue(reflect.ValueOf(collectionProp)) && (ok || !reflect.DeepEqual(v, collectionProp)) {
	obj["collection"] = collectionProp
}
nameProp, err := expandFirestoreFieldName(d.Get("name"), d, config)
if err != nil {
	return err
} else if v, ok := d.GetOkExists("name"); !isEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
	obj["name"] = nameProp
}

obj, err = resourceFirestoreFieldEncoder(d, meta, obj)
if err != nil {
	return err
}

url, err := replaceVars(d, config, "{{FirestoreBasePath}}{{name}}")
if err != nil {
	return err
}

log.Printf("[DEBUG] Deleting Field: %#v", obj)
project, err := getProject(d, config)
if err != nil {
	return err
}
res, err := sendRequestWithTimeout(config, "PATCH", project, url, obj, d.Timeout(schema.TimeoutDelete))
if err != nil {
	return fmt.Errorf("Error deleting Field: %s", err)
}

// Use the resource in the operation response to populate
// identity fields and d.Id() before read
var opRes map[string]interface{}
err = firestoreOperationWaitTimeWithResponse(
	config, res, &opRes, project, "Creating Field",
	d.Timeout(schema.TimeoutDelete))
if err != nil {
	return fmt.Errorf("Error waiting to delete Field: %s", err)
}

log.Printf("[DEBUG] Finished deleting Field %q: %#v", d.Id(), res)

return resourceFirestoreFieldRead(d, meta)
