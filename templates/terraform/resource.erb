<%- # the license inside this block applies to this file
# Copyright 2017 Google Inc.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
-%>
<%= lines(autogen_notice :go) -%>

package azurerm

<%= lines(compile(object.custom_code.constants)) if object.custom_code.constants -%>

<%
    resource_name = product_ns + object.name
    properties = object.all_user_properties
    # Fingerprints aren't *really* settable properties, but they behave like one. At Create, they have no value but they
    # can just be read in anyways, and after a Read they will need to be set in every Update.
    settable_properties = properties.reject{ |v| v.output && !v.is_a?(Api::Type::Fingerprint) }.reject(&:url_param_only)
    # PUT needs parameters like `name` to be set in the resource body, but we don't want to send them in PATCH
    update_body_properties = settable_properties
    update_body_properties = settable_properties.reject(&:input) if object.update_verb == :PATCH
    # Handwritten TF Operation objects will be shaped like accessContextManager while the Google Go Client will have a name like accesscontextmanager
    api_name_lower = String.new(product_ns)
    api_name_lower[0] = api_name_lower[0].downcase
    api_client_name = api_name_lower.downcase
    has_project = object.base_url.include?("{{project}}")
    has_self_link = (object.exports || []).any? { |e| e.is_a?(Api::Type::SelfLink)}
-%>
<%
    azure_is_resource_group = object.name == "ResourceGroup"
    azure_client_name = "#{object.api_name}Client".camelcase(:lower)
    sdk_package = azure_resource_go_package(object.__product)
-%>
<%
    combine_create_update = (object.azure_create_verb == object.azure_update_verb)
    create_func_name_postfix = (combine_create_update ? "CreateUpdate" : "Create")
    update_func_name_postfix = (combine_create_update ? "CreateUpdate" : "Update")
-%>

func resource<%= resource_name -%>() *schema.Resource {
    return &schema.Resource{
        Create: resource<%= resource_name -%><%= create_func_name_postfix -%>,
        Read: resource<%= resource_name -%>Read,
<%      if updatable?(object, properties) -%>
        Update: resource<%= resource_name -%><%= update_func_name_postfix -%>,
<%      end -%>
        Delete: resource<%= resource_name -%>Delete,
<%      if settable_properties.any? {|p| p.unordered_list} && !object.custom_code.resource_definition -%>
        CustomizeDiff: customdiff.All(
<%=         
            settable_properties.select { |p| p.unordered_list }
                               .map { |p| "resource#{resource_name}#{p.name.camelize(:upper)}SetStyleDiff"}
                               .join(",\n")
-%>
        ),
<%      end -%>

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },

<%      unless object.async.nil? -%>
        Timeouts: &schema.ResourceTimeout {
            Create: schema.DefaultTimeout(<%= object.async.operation.timeouts.insert_sec -%> * time.Second),
<%          if updatable?(object, properties) -%>
            Update: schema.DefaultTimeout(<%= object.async.operation.timeouts.update_sec -%> * time.Second),
<%          end -%>
            Delete: schema.DefaultTimeout(<%= object.async.operation.timeouts.delete_sec -%> * time.Second),
        },
<%      end -%>
<%=     lines(compile(object.custom_code.resource_definition)) if object.custom_code.resource_definition -%>

        Schema: map[string]*schema.Schema{
<%          order_properties(properties).each do |prop| -%>
<%=             lines(build_schema_property(prop, object, 12)) -%>
<%          end -%>
<%=         lines(compile(object.custom_code.extra_schema_entry)) if object.custom_code.extra_schema_entry -%>
<%          if has_project -%>
            "project": {
                Type:     schema.TypeString,
                Optional: true,
                Computed: true,
                ForceNew: true,
            },
<%          end -%>
<%          if has_self_link -%>
            "self_link": {
                Type:     schema.TypeString,
                Computed: true,
            },
<%          end -%>
        },
    }
}
<% settable_properties.select {|p| p.unordered_list}.each do |prop| -%>
func resource<%= resource_name -%><%= prop.name.camelize(:upper) -%>SetStyleDiff(diff *schema.ResourceDiff, meta interface{}) error {
<%=
    compile_template('templates/terraform/unordered_list_customize_diff.erb',
                     prop: prop,
                     resource_name: resource_name)
-%>
}
<% end -%>

func resource<%= resource_name -%><%= create_func_name_postfix -%>(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).<%= azure_client_name -%>

    ctx := meta.(*ArmClient).StopContext

<%  settable_properties.each do |prop| -%>
<%    output_var = (prop.name == "resourceGroupName" ? "resourceGroup" : prop.name.camelcase(:lower)) -%>
<%=   lines(build_schema_property_get('d', output_var, prop, object, 4)) -%>
<%  end -%>

<%  sdk_type_def = object.azure_sdk_type_defs["/"] -%>
<%= lines(build_property_to_sdk_object("parameters := ", "/", sdk_type_def, sdk_package, resource_name, settable_properties, object)) -%>

<%  if object.custom_code.encoder -%>
    obj, err = resource<%= resource_name -%>Encoder(d, meta, obj)
    if err != nil {
        return err
    }
<%  end -%>

<%  if object.mutex -%>
    lockName, err := replaceVars(d, config, "<%= object.mutex -%>")
    if err != nil {
        return err
    }
    mutexKV.Lock(lockName)
    defer mutexKV.Unlock(lockName)
<%  end -%>

<%  unless object.azure_create_async -%>
    if _, err := client.<%= object.azure_create_verb -%>(ctx<%= ", resourceGroup" unless azure_is_resource_group -%>, name, parameters); err != nil {
        return fmt.Errorf("Error creating <%= object.name -%>: %+v", err)
    }
<%  else -%>
    future, err := client.<%= object.azure_create_verb -%>(ctx<%= ", resourceGroup" unless azure_is_resource_group -%>, name, parameters)
    if err != nil {
        return fmt.Errorf("Error creating <%= object.name -%> %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of <%= object.name -%> %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
<%  end -%>

<%= lines(compile(object.custom_code.post_create)) if object.custom_code.post_create -%>

    resp, err := client.<%= object.azure_read_verb -%>(ctx<%= ", resourceGroup" unless azure_is_resource_group -%>, name)
    if err != nil {
        return err
    }
    if read.ID == nil {
        return fmt.Errorf("Cannot read <%= object.name -%> %q", name)
    }
    d.SetId(*resp.ID)

    return resource<%= resource_name -%>Read(d, meta)
}

func resource<%= resource_name -%>Read(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).<%= azure_client_name -%>

    ctx := meta.(*ArmClient).StopContext

    id, err := parseAzureResourceID(d.Id())
    if err != nil {
        return fmt.Errorf("Error parsing <%= object.name -%> ID %q: %+v", d.Id(), err)
    }
<%  if azure_is_resource_group -%>
    name := id.ResourceGroup
<%  else -%>
    resourceGroup := id.ResourceGroup
    name := id.Path["<%= object.azure_id_portion -%>"]
<%  end -%>

    resp, err := client.<%= object.azure_read_verb -%>(ctx<%= ", resourceGroup" unless azure_is_resource_group -%>, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] <%= object.name -%> %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading <%= object.name -%>: %+v", err)
    }

<%  unless object.self_link_query.nil? -%>
<%#     This part of the template extracts the one resource we're interested in
        from the list that gets returned.  self_link_query is a field which
        describes a list result from a read. -%>
<%=     compile_template('templates/terraform/self_link_query.erb',
                         object: object,
                         settable_properties: settable_properties,
                         resource_name: resource_name) -%>
<% end -%>

<%  if object.custom_code.decoder -%>
    res, err = resource<%= resource_name -%>Decoder(d, meta, res)
    if err != nil {
        return err
    }
<%  end -%>

<%  properties.each do |prop| -%>
<%    input_var = (prop.name == "resourceGroupName" ? "resourceGroup" : "resp.#{prop.azure_api_path.camelcase(:upper)}") -%>
<%=   lines(build_schema_property_set(input_var, 'd', prop, object, 4)) -%>
<%  end -%>

    return nil
}

<%  if !combine_create_update -%>
func resource<%= resource_name -%><%= update_func_name_postfix -%>(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).<%= azure_client_name -%>

    ctx := meta.(*ArmClient).StopContext

    id, err := parseAzureResourceID(d.Id())
    if err != nil {
        return fmt.Errorf("Error parsing <%= object.name -%> ID %q: %+v", d.Id(), err)
    }
<%  if azure_is_resource_group -%>
    name := id.ResourceGroup
<%  else -%>
    resourceGroup := id.ResourceGroup
    name := id.Path["<%= object.azure_id_portion -%>"]
<%  end -%>

    // TODO: Complete Update Function
}
<%  end -%>

func resource<%= resource_name -%>Delete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).<%= azure_client_name -%>

    ctx := meta.(*ArmClient).StopContext

<%  if object.mutex -%>
    lockName, err := replaceVars(d, config, "<%= object.mutex -%>")
    if err != nil {
        return err
    }
    mutexKV.Lock(lockName)
    defer mutexKV.Unlock(lockName)
<%  end -%>

    id, err := parseAzureResourceID(d.Id())
    if err != nil {
        return fmt.Errorf("Error parsing <%= object.name -%> ID %q: %+v", d.Id(), err)
    }
<%  if azure_is_resource_group -%>
    name := id.ResourceGroup
<%  else -%>
    resourceGroup := id.ResourceGroup
    name := id.Path["<%= object.azure_id_portion -%>"]
<%  end -%>

<%  unless object.azure_delete_async -%>
    // TODO: Synced Delete Operation
<%  else -%>
    future, err := client.<%= object.azure_delete_verb -%>(ctx<%= ", resourceGroup" unless azure_is_resource_group -%>, name)
    if err != nil {
        if response.WasNotFound(future.Response()) {
            return nil
        }
        return fmt.Errorf("Error deleting <%= object.name -%> %q: %+v", name, err)
    }

    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        if !response.WasNotFound(future.Response()) {
            return fmt.Errorf("Error waiting for deleting <%= object.name -%> %q: %+v", name, err)
        }
    }
<%  end -%>

    return nil
}

<% if object.custom_code.encoder -%>
func resource<%= resource_name -%>Encoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
<%= lines(compile(object.custom_code.encoder)) -%>
}
<% end -%>

<% if object.custom_code.update_encoder-%>
func resource<%= resource_name -%>UpdateEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
<%= lines(compile(object.custom_code.update_encoder)) -%>
}
<% end -%>

<% if object.custom_code.decoder -%>
func resource<%= resource_name -%>Decoder(d *schema.ResourceData, meta interface{}, res map[string]interface{}) (map[string]interface{}, error) {
<%= lines(compile(object.custom_code.decoder)) -%>
}
<% end -%>
