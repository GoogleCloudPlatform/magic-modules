func expandCloudIotDeviceRegistryStateNotificationConfig(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
    original := v.(map[string]interface{})
    transformed := make(map[string]interface{})

    transformedPubsubTopicName, err := expandCloudIotDeviceRegistryEventNotificationConfigsPubsubTopicName(original["pubsub_topic_name"], d, config)
    if err != nil {
        return nil, err
    } else if val := reflect.ValueOf(transformedPubsubTopicName); val.IsValid() && !isEmptyValue(val) {
        transformed["pubsubTopicName"] = transformedPubsubTopicName
    }

    return transformed, nil
}

func expandCloudIotDeviceRegistryStateNotificationConfigPubsubTopicName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
    return v, nil
}

func flattenCloudIotDeviceRegistryStateNotificationConfig(v interface{}, d *schema.ResourceData, config *Config) interface{} {
    if v == nil {
        return v
    }

    original := v.(map[string]interface{})
    transformed := make(map[string]interface{})

    transformedPubsubTopicName := flattenCloudIotDeviceRegistryStateNotificationConfigPubsubTopicName(original["pubsubTopicName"], d, config)
    transformed["pubsub_topic_name"] = transformedPubsubTopicName

    return transformed
}

func flattenCloudIotDeviceRegistryStateNotificationConfigPubsubTopicName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
    return v
}

func validateCloudIotDeviceRegistryID(v interface{}, k string) (warnings []string, errors []error) {
    value := v.(string)
    if strings.HasPrefix(value, "goog") {
        errors = append(errors, fmt.Errorf(
            "%q (%q) can not start with \"goog\"", k, value))
    }
    if !regexp.MustCompile(CloudIoTIdRegex).MatchString(value) {
        errors = append(errors, fmt.Errorf(
            "%q (%q) doesn't match regexp %q", k, value, CloudIoTIdRegex))
    }
    return
}

func validateCloudIotDeviceRegistrySubfolderMatch(v interface{}, k string) (warnings []string, errors []error) {
    value := v.(string)
    if strings.HasPrefix(value, "/") {
        errors = append(errors, fmt.Errorf(
            "%q (%q) can not start with '/'", k, value))
    }
    return
}
