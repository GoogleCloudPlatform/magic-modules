// if disks are attached, they must be detached before the disk can be deleted
if instances, ok := d.Get("users").([]interface{}); ok {
	type detachArgs struct{ project, zone, instance, deviceName string }
	var detachCalls []detachArgs
	self := d.Get("self_link").(string)
	for _, instance := range instances {
		if !computeDiskUserRegex.MatchString(instance.(string)) {
			return fmt.Errorf("Unknown user %q of disk %q", instance, self)
		}
		matches := computeDiskUserRegex.FindStringSubmatch(instance.(string))
		instanceProject := matches[1]
		instanceZone := matches[2]
		instanceName := matches[3]
		i, err := config.clientCompute.Instances.Get(instanceProject, instanceZone, instanceName).Do()
		if err != nil {
			if gerr, ok := err.(*googleapi.Error); ok && gerr.Code == 404 {
				log.Printf("[WARN] instance %q not found, not bothering to detach disks", instance.(string))
				continue
			}
			return fmt.Errorf("Error retrieving instance %s: %s", instance.(string), err.Error())
		}
		for _, disk := range i.Disks {
			if disk.Source == self {
				detachCalls = append(detachCalls, detachArgs{
					project:    instanceProject,
					zone:       GetResourceNameFromSelfLink(i.Zone),
					instance:   i.Name,
					deviceName: disk.DeviceName,
				})
			}
		}
	}
	for _, call := range detachCalls {
		op, err := config.clientCompute.Instances.DetachDisk(call.project, call.zone, call.instance, call.deviceName).Do()
		if err != nil {
			return fmt.Errorf("Error detaching disk %s from instance %s/%s/%s: %s", call.deviceName, call.project,
				call.zone, call.instance, err.Error())
		}
		err = computeOperationWait(config.clientCompute, op, call.project,
			fmt.Sprintf("Detaching disk from %s/%s/%s", call.project, call.zone, call.instance))
		if err != nil {
			if opErr, ok := err.(ComputeOperationError); ok && len(opErr.Errors) == 1 && opErr.Errors[0].Code == "RESOURCE_NOT_FOUND" {
				log.Printf("[WARN] instance %q was deleted while awaiting detach", call.instance)
				continue
			}
			return err
		}
	}
}
